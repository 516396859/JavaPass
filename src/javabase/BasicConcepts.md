---
title: 基本概念
icon: file
order: 1
author: Ms.Cheney
date: 2023-10-05
PageView: true
lastUpdated: true
category:
    - Java 基础
copyright: false
footer: 赣ICP备2023007682 | 使用 <a href="https://theme-hope.vuejs.press/zh/" target="_blank">VuePress Theme Hope</a> 主题 | MIT 协议, 版权所有 © 2023-Cheney,2018-present Mr.Hope
# 版权声明：本文为JavaPass博主「javapass.cn」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
---


::: tip 
- :star: 越多表示题目出现的频率较高，建议重点掌握。
- :one: :two: :three: :four: :five: 数字越大表示题目的难度系数越高，建议结合:star:情况进行选择。
- 如果题评说了必知必会，那么无论是否频率低请一定要记住，否则面试效果大打折扣。
:::

### 1. Java 语言的基本特点? :star: :one:
- 面向对象（封装，继承，多态）；
- 平台无关性（ Java 虚拟机实现平台无关性）；
- 编译与解释并存 ( .java文件编译成字节码 .class，解释器对字节码进行解释运行)；
- 支持多线程 (C++、Python 语法层面不支持多线程)；

**题评：** 此题不难，属于必知必会的知识点，中大厂基本不会问，银行和一些微小厂可能会问到。属于答出来了不加分，答不出来直接挂的题目。记忆关键词即可，然后按照自己的理解展开括号中的内容即可。可以自我发挥，但围绕这几个关键词展开即可，一定记住前面两个关键词，后两个尽量记住。

::: details 点击查看详细答案
Java 语言是一种面向对象的语言，它的三个主要特点是：封装、继承、多态。Java 语言的最具特色的地方就是它的平台无关性，也就是说，Java 语言编写的应用程序在不同的系统平台上都可以运行。Java 语言是一个编译与解释并存的语言，Java 语言编写的程序首先被编译成字节码，然后由 Java 解释器对字节码进行解释运行。Java 语言支持多线程，这对于实现高性能程序很重要。
:::

### 2. JVM 、 JDK 和 JRE 的区别? :star::star: :one:
- JVM 是 Java 虚拟机，JRE 是 Java 运行环境，JDK 是 Java 开发工具包。
- JVM 最小，JRE包括JVM和核心类库，JDK包括JRE和开发工具(jar、javadoc、javac)。

**题评：** 此题必知必会题。记忆技巧按照上面两点记忆，首先回答是什么，然后回答什么关系。详细请参考下面答案！
::: details 点击查看详细答案
- JVM（Java Virtual Machine）：JVM 是 Java 虚拟机的缩写，是 Java 运行时环境的一部分。JVM 是一个虚拟的计算机环境，它在实际计算机上模拟执行 Java 字节码（Java 编译后的中间代码）。负责将字节码翻译成特定计算机架构的机器代码，并执行 Java 程序。只要使用到了Java语言，就一定会涉及到 JVM。
- JRE（Java Runtime Environment）：JRE 是 Java 运行时环境的缩写，用于运行 Java 应用程序。JRE 包含了 JVM 和运行 Java 应用程序所需的 Java 类库。当用户要运行 Java 应用程序时，他们只需要安装 JRE，而不需要安装 JDK。而当用户想要开发 Java 应用程序时，他们就需要安装 JDK。
- JDK（Java Development Kit）：JDK 是 Java 开发工具包的缩写，用于开发 Java 应用程序。JDK 包含了 Java 编译器（javac）、Java 开发工具（如 javadoc、jar、debugger 等）、Java 类库（Java API）、以及一个 JRE（Java 运行时环境）。开发人员使用 JDK 来编写、编译和调试 Java 代码。
:::

### 3. 什么是字节码?采用字节码的好处是什么? :star::star: :one:
- 字节码是一种中间状态，介于源码和机器码之间的代码，字节码文件是以.class 结尾的文件。
- 好处：跨平台；性能优化；安全性高；
- 缺点：执行速度慢；占用更多的内存。(以防被回首掏)

**题评：** 此题必知必会题。同样的套路，首先回答是什么，再已知原理的情况下，很快能够想到好处和缺点。这就需要你提前看过一些更加详细的八股文，例如JavaGuide。

::: details 点击查看详细答案
在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件）只面向虚拟机。由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。注意的是 .class->机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。
以上答案来自JavaGuide，著作权归JavaGuide(javaguide.cn)所有,基于MIT协议,原文链接：https://javaguide.cn/java/basis/java-basic-questions-01.html
:::

### 4. 为什么说 Java 语言“编译与解释并存”? :star::star: :one:
- Java 语言是编译与解释共存的语言，Java 语言编写的程序首先被编译成字节码，然后由 Java 解释器对字节码进行解释运行。
- 并且使用了JIT（just-in-time compilation）对热代码进行运行时编译，提高运行效率。


### 5. 基本类型和包装类型的区别? :star::star: :one:
- 存储方式、占用空间、默认值、比较方式
::: details 点击查看详细答案
- 存储方式 ：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，几乎所有对象实例都存在于堆中。
- 占用空间 ：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。
- 默认值 ：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。
- 比较方式 ：对于基本数据类型来说，== 比较的是值。对于包装数据类型来说，== 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 equals() 方法。
:::

### 6. 基本移位运算符? :star: :one:
- `<<` 固定符号位左移运算符，num << 1,相当于num乘以2，-1 << 1 = -2
- `>>` 固定符号位右移运算符，num >> 1,相当于num除以2，-4 >> 1 = -2
- `>>>` 右移运算符，符号位也会移动，空位都以0补齐，-4 >>> 1 = 2147483646

### 介绍 Java 各种基本数据类型?
- 记忆顺序： `byte、short、int、long、float、double、char、boolean`。
- 所占字节大小分别是 `1、2、4、8、4、8、2、1` 个字节。
:::tip 记忆要诀
`byte` 是1字节，一直到`long` 8 字节不断翻倍。然后记住`float` 和 `int` 都是4字节，`double` 和 `long` 都是8字节。`char` 是2字节，`boolean` 不到1字节，一位即可。1字节等于8位，所以 `int` 有32位能够表达的数据范围是 `-2^31 ~ 2^31-1` 。
:::

### 包装类型的常量池技术|自动装箱的缓存机制?
- 缓存机制只针对包装类型，不包括基本数据类型，调用`XXX.valueof`装箱(自动装箱)的时候，避免频繁地`new Integer()`等，而是小范围内的包装类型直接从缓存中获取。`Byte,Short,Integer,Long` 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据， `Character` 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False  。两种浮点数类型的包装类 `Float,Double` 并没有实现常量池技术 。因此，使用包装类型的常量池中的对象都是相同的对象。

```java
Integer i1 = 40; //自动装箱，隐式调用Integer.valueOf(40)，得到缓存中的对象
Integer i2 = new Integer(40);// 创建的新对象
System.out.println(i1==i2); // 直接用==号，比较的是对象地址，结果为：false
```

### 为什么要有包装类型?
- 接住Null值，基本数据类型无法接住Null值，而包装类型可以。
- 泛型，泛型只能接受引用类型，不能是基本数据类型，所以需要包装类型。 
- 集合，集合中不能存放基本数据类型，只能存放包装类型。
::: details 点击查看详细答案
- 包装类型初始值可以是null值，基本数据类型初始值有默认值且不能为null，这在SQL查询返回整型时候可能会返回null，而用基本数据类型来接返回值可能在会发送空指针异常(自动装箱时调用null.valueof())。
- 例如ArrayList，HashSet等数据结果都是接受的是包装类型，这是因为包装类型都是Object的子类，所以才能使用泛型。
:::

### Java 方法是值传递还是引用传递?
- Java任何时候都是值传递，当传递对象时，传递的是对象的引用的值，也就是地址。
- 当传递基本数据类型时，传递的是基本数据类型的值。
- 补充：`swap(int a,int b)` 交换两个基本数据类型的值，是不行的，因为传递的是值，不是引用。`swap(Integer a,Integer b)` 交换两个包装类型的值，是可以的，因为传递的是引用的值，也就是地址。无论int还是Integer，都是值传递，只不过Integer是引用类型，传递的是引用的值，也就是地址。

### 什么是自动拆箱、装箱?

```java
Integer in = 10; //装箱:装箱其实就是调用了包装类的Integer.valueOf(10)方法
int n = in; //拆箱:拆箱其实就是调用了 in.intValue()方法。注意如果 in 为null将发生NullPointerException异常。
```

### 为什么浮点数运算的时候会有精度丢失的风险?
- 浮点数在计算机中是以二进制的形式存储的，而二进制无法精确表示十进制小数，所以会有精度丢失的风险。
- 十进制下的 0.2 就没办法精确转换成二进制小数：0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数或者小数部分为0为止。

### 如何解决浮点数运算的精度丢失问题?
- 如果非要使用基本数据类型例如double，那么需要使用指定一个误差范围，然后在比较的时候，两个数的差值小于这个误差范围，就认为这两个数相等。
- 建议直接使用BigDecimal类并，然后讲一下BigDecimal类原理；
::: details 点击查看详细答案
- BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。BigDecimal 的实现利用到了 BigInteger （用来操作大整数）, 所不同的是 BigDecimal 加入了小数位的概念。BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。相对于常规整数类型的运算来说，BigInteger 运算的效率会相对较低。
- BigDecimal类型的变量比较大小使用compareTo()方法，equals() 方法不仅仅会比较值的大小（value）还会比较精度（scale），而 compareTo() 方法比较的时候会忽略精度。
:::
### 超过Long类型的数据如何存储?
- 使用BigInteget存储；BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。

### 重写与重载?
- 重载：同一个类中，方法名相同，参数列表不同，与返回值无关。
- 重写：子类重写父类的方法，方法名相同，参数列表相同，返回值相同或者是子类的返回值是父类返回值的子类。

### 成员变量与局部变量的区别?
定义的位置不同、默认值不同、内存中的位置不同、生命周期不同。
::: details 点击查看详细答案
- 定义的位置不同：成员变量在局部代码块之外；局部变量在局部代码块中；
- 内存中的位置不同：成员变量对象可以被static修饰—属于类的——存放在运行时常量池中（堆中），不被static修饰的对象—存储在堆中；局部变量不能被static修饰—存储在栈内存的局部变量表中。
- 生命周期不同：成员变量是对象（类）的一部分，随着对象创建（类）而创建销毁而销毁；局部变量随着方法调用结束而结束；
- 默认值不同：一般讨论基本数据类型和包装类对象，成员变量有默认值，局部变量需要赋值；数组局部变量也有默认值！
:::

### 静态变量static修饰?
它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。通常情况下，静态变量会被 final 关键字修饰成为常量。

### 静态方法为什么不能调用非静态成员?
静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

### 面向对象三大特征?
- 封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式。
- 继承：子类继承父类的属性和方法。
- 多态：父类引用指向子类对象，`Animal dog = new Dog()`。
::: details 点击查看详细答案
- 封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法get()、 set()来操作属性。 
- 继承，不同类型的对象，相互之间经常有一定数量的共同点。
关于继承如下 3 点请记住： 
a. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。
b. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
c. 子类可以用自己的方式实现父类的方法（重写）。
- 多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。
多态的特点: 
a. 对象类型和引用类型之间具有继承（抽象类）/实现（接口）的关系；
b. 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；
c. 多态不能调用“只在子类存在但在父类不存在”的方法；
d. 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。
:::