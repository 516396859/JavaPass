---
title: 基本概念
icon: file
order: 6
author: Ms.Cheney
date: 2023-10-05
PageView: true
lastUpdated: true
category:
    - Java 基础
copyright: false
footer: 赣ICP备2023007682 | 使用 <a href="https://theme-hope.vuejs.press/zh/" target="_blank">VuePress Theme Hope</a> 主题 | MIT 协议, 版权所有 © 2023-Cheney,2018-present Mr.Hope
# 版权声明：本文为JavaPass博主「javapass.cn」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
---




::: tip 
- :star: 越多表示题目出现的频率较高，建议重点掌握。
- :one: :two: :three: :four: :five: 数字越大表示题目的难度系数越高，建议结合:star:情况进行选择。
- 如果题评说了必知必会，那么无论是否频率低请一定要记住，否则面试效果大打折扣。
:::

### 1. 多线程的安全问题:star::star::star::star::three:
线程安全指的是：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的，或者说共享数据块每一时刻都只能有一个线程操作。

程序存在线程安全问题的条件：
- 是否是多线程（单线程没有线程安全问题，例如Redis）
- 是否共享数据 (数据不共享一般不会有安全性问题，例如ThreadLocal)
- 是否多个条语句操作共享数据 (主要指的是多线程环境下的写操作，读操作没有安全性问题)

保证多线程安全的方法：只需要将共享数据的代码锁起来，让任意时刻只有一个线程在执行即可。造成多线程安全问题的真正原因：并发环境下`CPU`上下文切换导致指令的交错执行，操作同一数据。也就是上述三个条件。

**题评：** 这个题目很重要哦，一般会结合项目来问！至少以上三点你应该掌握！
::: details 点击查看详细答案
待补充...
:::

### 2. 谈谈`Lock`锁:star::star::star::three:
`Java`还提供了功能更加强大的加锁和释放锁的方法，`Lock`锁不能直接实例化，需要采用它的实现类`ReentrantLock`来实例化，提供了`lock()`加锁和`unlock()`释放锁。`Synchronized`，它是`java`语言的关键字，需要`jvm`实现   ；`ReentrantLock`它是`JDK` `1`.`5`之后提供的`API`层面的互斥锁 ；
- 等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待 ；
- 公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，`Synchronized`锁非公平锁，`ReentrantLock`默认的构造函数是创建的非公平锁，可以通过参数`true`设为公平锁 。
- 锁绑定多个条件，一个`ReentrantLock`对象可以同时绑定多个对象。

**题评：** 谈`Lock`接口，主要要说出它的实现类`ReentrantLock`的原理和特性。
::: details 点击查看详细答案
待补充...
:::

### 3. `ReentrantLock` 是什么？:star::star::star::star::star::three:
`ReentrantLock` 实现了 `Lock` 接口，是一个可重入且独占式的锁，和 `synchronized` 关键字类似。不过，`ReentrantLock` 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。 `ReentrantLock` 的底层就是由 `AQS` 来实现的。

**题评：** `ReentrantLock` 知道这些远远不够，底层`AQS`实现也需要懂，后面会有`AQS`的讲解，但是以上是总结的精华，每一个特性你是否懂，不懂就去学。
::: details 点击查看详细答案
待补充...
:::

### 4. 如何停止一个正在运行的线程:star::star::star::two:
- 使用退出标志`flag`，程序运行结束
- 使用`stop`方法强行终止
- 使用`interrupt`方法中断线程

**题评：** 每种方法的背后需要知道，上面简述只是回答面试官的答案，你需要根据上面的提示说出背后的原理！切记，`JavaPass`不是减轻你的背诵，而是通过简单的答案唤醒你的知识记忆！
::: details 点击查看详细答案
待补充...
:::

### 5. `sleep()`和`wait()` 有什么区别？:star::star::star::star::star::three:
`sleep`方法属于`Thread`类，`wait`方法属于`Object`类。当调用`wait()`方法的时候，线程会放弃对象锁，进入此对象的等待队列中挂起 。只有针对此对象调用`notify()`方法后本线程才进入对象同步队列竞争锁对象。
- `sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁 。
- `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()` 方法。`sleep()`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long` `timeout)` 超时后线程会自动苏醒。
- `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。

**题评：** 以上能说出多少说多少，最好全部能够记住，但是每一个点都需要掌握！
::: details 点击查看详细答案
待补充...
:::

### 6. 为什么 `wait()` 方法不定义在 `Thread` 中？:star::star::star::star::star::three:
`wait` 方法是`Object`的方法，每个对象都有，是让自己释放当前的对象锁并挂起，对象锁是在对象头的`MarkWord`中，重量级锁对象是通过监视器对象实现的，因此当调用`wait`方法就会将当前线程挂起并加入到当前监视器的等待队列中。以上说明与`wait`打交道的都是对象，因此`wait`方法释放锁是操作对象而不是`Tread`类。为什么 `sleep()` 方法定义在 `Thread` 中？因为 `sleep()` 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。

**题评：** 需要理解透彻！很常考！
::: details 点击查看详细答案
待补充...
:::

### 7. 为什么`wait`, `notify` 和 `notifyAll`这些方法不在`thread`类里面？:star::star::star::star::star::three:
`JAVA`提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。上面的答案符合本题！

**题评：** 同上！
::: details 点击查看详细答案
待补充
:::

### 8. 为什么`wait`和`notify`方法要在同步块中调用？:star::star::star::star::star::three:
只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的`wait()`,`notify()`和`notifyAll()`方法。`wait()`方法强制当前线程释放对象锁。这意味着在调用某对象的`wait()`方法之前，当前线程必须已经获得该对象的锁。在调用对象的`notify()`和`notifyAll()`方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的`notify()`或`notifyAll()`方法。

**题评：** 同一类题。
::: details 点击查看详细答案
待补充...
:::

### 9. 线程和进程的区别:star::star::star::star::two:
- 进程是系统资源调配的最小单位，线程是操作系统执行的最小单元；
- 一个进程包含多个线程，多个线程共享同属进程的资源。
- 进程是程序的一次执行过程。一般一次用户请求是一个线程。
- 线程的切换速度比进程快多了。

**题评：** 重点简单题！
::: details 点击查看详细答案
待补充...
:::

### 10. 并行和并发的区别:star::star::star::one:
并行是多核真正的同时执行，并发是单核上下文切换串行执行。在多核操作系统中既有并行也有并发，因为进程和线程数大于`CPU`内核数。

**题评：** 必知必会题
::: details 点击查看详细答案
待补充...
:::

### 11. 同步和异步的区别:star::star::star::star::star::three:
- 同步：往往伴随阻塞和等待，即当一个任务调用另外一个任务时，需要阻塞式等待另一个任务运行完毕返回结果就是同步；
- 异步：如果不需要等待结果立即返回的是异步；异步效率更高，例如`redis`中`keys`是同步命令，`scans`是异步命令。

**题评：** 同步，异步这种概念要非常清楚。`IO`有同步异步，异步效率往往比同步更高；锁一定是同步锁；线程有同步和异步，同步通过锁实现，异步通过`FutureTask`类等实现；同步一般和阻塞、串行、等待相关。
::: details 点击查看详细答案
待补充...
:::

### 12. 什么是线程同步:star::star::star::star::two:
在多线程并发时，线程同步是保证多个线程之间执行的一致性和正确性，采用同步的机制使得多个线程并发执行就像单线程一样不会发生线程安全问题，达到类似同步串行执行的效果，通常使用互斥锁、乐观锁、`join`等机制保证线程同步。保证数据一致性和安全性。

**题评：** 重点题
::: details 点击查看详细答案
待补充...
:::

### 13. 线程创建的四种方式:star::star::star::star::two:
- 继承`Thread`重写`run`方法，缺点需要继承
- 实现`Runnable`重写`run`方法，`target`作为`Thread`参数执行，多实现
- 实现`Callable`重写`call`方法，作为`FutureTask`的参数，再作为`Thread`的参数；异步执行，当启动线程后，可以通过`FutureTask`对象`get`方法获得执行结果或者异常信息。
-  线程池技术

**题评：** 重点题
::: details 点击查看详细答案
待补充...
:::

### 14. `Thread`中`start()` 和 `run()` 方法的区别:star::star::star::one:
`run()` 当前线程作为普通方法执行一次，只有`start`才会开启新的线程去执行`run`方法

**题评：** 简单题
::: details 点击查看详细答案
待补充...
:::

### 15. 关于线程操作的常用方法:star::star::star::star::two:
 `start`、`yield`、`join`、`wait`、`notify`、`setDaemon(true)`

**题评：** 不是让你只记住上面几个单词，而是上面每一个方法是干嘛用的需要你说出来！
::: details 点击查看详细答案
待补充...
:::

### 16. 聊聊中断方法`interrupt` :star::star::star::star::three:
`interrupt`不会像`stop`暴力终止线程，而是将中断标志位设置为`true`，线程执行不会被直接打断而是需要开发者自己编写代码判断`interrupt`标志位来终止线程。当处于`sleep`、`wait`、`join`阻塞状态时，会打断阻塞立即抛出一个中断异常，在异常中可以选择重新设置标志位继续执行或者结束执行。如果不在阻塞状态则会中断线程执行，需要自己释放资源避免死锁。

**题评：** 重点题
::: details 点击查看详细答案
待补充...
:::

### 17. `interrupted()` 和  `isInterrupted()` 的区别:star::star::star::star::two:
都是判断线程是中断标记的，带`is`的调用该方法后不会清除打断标记（当为`true`时调用该方法后重置为`false`），不带`is`的会重新清除打断标记重置为`false`

**题评：** 待补充
::: details 点击查看详细答案
待补充
:::

### 18. 线程优雅终止——两阶段终止模式:star::star::star::star::three:
在一个线程 `T1` 中如何优雅终止线程 `T2`？ 两阶段指的是线程`T2`运行阶段和`T2`阻塞阶段，`T1`中通过`interrupt`打断`T2`在运行阶段没问题，可以在`T2`中判断打断标志从而释放资源，`return`终止线程。对于阻塞阶段，打断会抛出打断异常（捕获即可进入运行阶段），我们捕获打断异常中通过调用 `thread`.`interrupt()` 重设打断标记，再次打断现在处于运行阶段的`T2`来达到打断`T2`的目的。

**题评：** 记住运行阶段和阻塞阶段两个阶段的不同处理方式即可！
::: details 点击查看详细答案
待补充
:::

### 19. `Daemon`守护线程:star::star::star::one:
`GC`线程就是守护线程，也叫后台线程，当所有的前台线程都被销毁了，守护线程才能结束。

**题评：** 没用了前台线程，守护线程才销毁，否则一直后台执行。
::: details 点击查看详细答案
待补充
:::

### 20. 线程（原理）运行机制:star::star::star::star::four:
每个线程启动后，虚拟机就为其分配一块栈内存，存放栈帧；程序计数器记住下一条字节码的执行地址，存放在方法栈中。当发生上下文切换的时候，需要保存当前线程状态信息到程序控制块中，并恢复另外一个线程。线程的调度是在内核态运行的，而线程中的代码是在用户态运行的。所以线程切换会导致用户态和内核态进行系统调用。

**题评：** 一定要结合`JVM`来理解，难度为`4`及以上难度的可以专门标记起来后面反复学习。
::: details 点击查看详细答案
待补充
:::

### 21. 线程调度方式:star::star::star::two:
- 分时调度模型，让所有线程轮流获得`CPU`的执行权，轮询执行，平均占用时间片。
- 抢占式调度，让优先级更高的线程占用`CPU`，同一优先级随机挑，高优先级只是高概率！可能导致低优先级的线程饥饿。

**题评：** 一般记这两种就行！
::: details 点击查看详细答案
待补充
:::

### 22. 线程状态:star::star::star::star::three:
从操作系统来讲有五种状态：新建状态、就绪状态、运行态、阻塞态、终止态；
从`JVM`讲：新建态、运行态（包括了就绪态）、限时等待状态（`sleep(2000)`，`wait(2000)`，`join(2000)` ），等待状态（`wait`，`join`，`park`），阻塞态（同步队列），终止态。

**题评：** 可以理解为`JVM`的各种等待状态和阻塞状态等价于操作系统的阻塞状态，然后`JVM`的运行态包括了就绪态。最后一定要搞清楚什么是等待队列什么是同步队列！下一题就讲这个！
::: details 点击查看详细答案
待补充
:::

### 23. 同步队列和等待队列的区别:star::star::star::star::three:
- 等待队列（需要唤醒的线程，对应的是等待和限时等状态）：存放的是等待唤醒的线程（调用`wait`、`join`后的状态是等待状态），`notify`唤醒后进入同步队列。
- 同步队列（需要抢锁的线程，对应的是阻塞状态）：唤醒后的线程并不是立即可以执行，而是需要去抢占同步方法对象的锁，需要进入对象锁的同步队列中排队。

**题评：** 搞清楚就行！
::: details 点击查看详细答案
待补充
:::

### 24. 你是如何解决生产者和消费者问题:star::star::star::star::three:
最佳方式：使用`Semaphore`信号量控制并发或者使用`BlackingQueue`来实现生产者消费者模式；

**题评：** 可能要你手写一个生产者、消费者模式！这个要会，不难！
::: details 点击查看详细答案
待补充
:::

### 25. 如何避免死锁？:star::star::star::star::three:
破坏死锁的四个条件之一：互斥条件、请求与保持、不可剥夺、循环等待；
设置超时释放、请求不到资源就释放已有资源（破坏请求与保持条件）、优先级高的线程可以剥夺优先级低的线程（破坏不可剥夺条件）、按顺序申请资源再执行（持有`A`资源才可以申请`B`资源，以此类推，破坏循环等待条件）

**题评：** 互斥条件一般无法破坏
::: details 点击查看详细答案
待补充
:::

### 26. 判断一个线程是否拥有锁:star::star::one:
`Thread`.`holdLock()`，返回是否拥有对象锁；

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 27. `Java`线程池中`submit()` 和 `execute()`方法有什么区别？  :star::star::star::star::three:
- `submit()` 的参数只能是 `Runnable` 对象，`execute()` 方法参数可以是 `Runnable`对象和`Callable()`对象，因此决定了返回值的不一样。
- 两个方法都可以向线程池提交任务，`execute()`方法的返回类型是`void`，而`submit()`方法可以返回持有计算结果的`Future`对象，而可以从`Future`对象中获取结果或者异常信息；

**题评：** 重点题
::: details 点击查看详细答案
待补充
:::

### 28. 什么是阻塞式方法？:star::star::one:
阻塞式方法是指程序会一直等待该方法完成期间不做其他事情；例如`Semaphore`的`acquire()`是阻塞方法；

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 29. 什么是线程安全，保证线程安全的方法有哪些？:star::star::star::star::star::three:
线程安全就是在多线程并发访问的环境下保证数据的一致性与可靠性，就像单线程一样不出差错。保证线程安全的方法：加锁、使用`JUC`同步类、使用`ThreadLocal`、乐观锁。

**题评：** 这个时候相信你已经可以自己说了！
::: details 点击查看详细答案
待补充
:::

### 30. `Java`中`Semaphore`是什么:star::star::star::star::two:
信号量同步机制，可以限制同时访问某个资源的并发线程数量，`acquire()`方法获取锁，或者通过`release()`方法释放锁。当超过最大并发数则陷入阻塞直到别的线程释放；底层是`Semaphore`维护了一个计数器，该计数器表示可用的许可数量。

**题评：** `Semaphore(n)` 表示共享锁最多可以被`n`个线程同时持有！
::: details 点击查看详细答案
待补充
:::

### 31. 在多线程中，什么是上下文切换`(context`-`switching)`？:star::star::star::two:
上下文切换指的是`CPU`执行不同线程的代码的切换，涉及到用户态和内核态的切换过程，开销很大。在时间片或者阻塞时会发生上下文切换；

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 32. `Java`中的`ReadWriteLock`是什么？:star::star::star::two:
读写锁，`JDK`中`ReentrantReadWriteLock`实现了读写锁，读锁是共享锁，写锁是独占锁；

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 33. 多线程中的忙循环是什么?:star::star::star::one:
忙循环指的是一个空循环，用来避免上下文切换，适合短暂的阻塞，例如轻量级锁；不适合大量线程争夺锁的情况下（只有一个线程获取锁），会引起`CPU`压力暴增，效率低下；

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 34. `volatile` 变量和 `atomic` 变量有什么不同？:star::star::star::star::two:
`volatile` 变量保证变量的线程可见性和避免指令重排；`atomic`变量是原子变量，用来保证变量的原子性，例如 `a`++不是原子操作，但是而`AtomicInteger` 是原子操作；

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 35. 如何在`Java`中创建线程安全的`Singleton`？:star::star::star::star::star::three:
- 饿汉模式，采用静态常量创建单例对象；
- 懒汉模式的`DCL`模式，注意使用`volatile`修饰单例对象；

**题评：** 经常考！
::: details 点击查看详细答案
待补充
:::

### 36. `Java`中什么是竞态条件？:star::star::star::three:
多线程并发执行时执行结果依赖于线程执行的顺序，结果不唯一的情况成为竞态条件；多个线程修改一个共享变量时发生；避免竞态条件发生：锁、`JUC`并发类；

**题评：** 这种题是扣专业词汇的！作为计算机专业学生的整个词汇没听过大打折扣！
::: details 点击查看详细答案
待补充
:::

### 37. 什么是`FutureTask`？:star::star::star::star::star::four:
`FutureTask`表示一个异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成`get`方法将会阻塞。一个`FutureTask`对象可以对`Callable`和`Runnable`的对象进行包装，但是`Runnable`对象没有返回结果，因此执行完`Runnable`后`FutureTask`包装返回`null`值；

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 38. `Callable`和`Future` 的关系?:star::star::star::star::three:
`Callable`开启线程是并行的，我们必须等待它返回结果。而使用`Future`，线程池提交`Callable`任务后返回了一个`Future`对象，我们可以通过`future`对象得知任务状态和执行结果，`get`阻塞式获取结果。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 39. `Java`中同步集合和并发集合的区别？:star::star::star::star::three:
它们都是为多线程提供线程安全的集合，差别是性能方面的；同步集合一般使用`synchronized` 等加锁机制实现，而`JUC`中的很多方法都进行了极限优化，优化方法不限于分段锁、乐观锁、`AQS`等机制；并且提供了更强大的原子类，性能更好；一般情况下优先使用并发集合；

**题评：** 不清楚建议先学习一下`JUC`！
::: details 点击查看详细答案
待补充
:::

### 40. `Java`中活锁和死锁的区别？:star::star::star::two:
- 死锁就是线程相互等待对方释放资源，而自己得不到资源一直不释放，造成的循环等待。
- 活锁就是线程不断改变自己的状态或者执行目的是避免阻塞，然后对方也是在动态调整，导致线程一直在改变状态。你让我，我让你，最后谁也没让成。破坏死锁条件之一的请求与保持（当请求的资源被占用就释放自己已有的资源）可以解决死锁，但也可能导致活锁。例如 线程`t1`占用资源`A`，线程`t2`占用资源`B`，现在都需要申请另外一个资源（也就是对方的资源）于是发现被占用就释放自己已有的资源，这时候都释放了资源重新抢占资源，很可能又会发生这种情况一直进行下去。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 41. `Java`中如何获取线程的堆栈信息:star::star::star::two:
使用`jstack`查看线程和栈的信息

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 42. 如果同步块内的线程抛出异常会发生什么？:star::star::star::star::four:
当前线程终止执行，无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我们更喜欢同步块，因为它不用花费精力去释放锁，`ReentrantLock`可以在`finally` `block`里释放锁。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 43. 一个线程运行时发生异常会怎么样？:star::star::star::star::three:
如果没有被捕获则线程停止执行，状态为终止状态；如果不在同步块中则无法及时释放占有的资源；如果捕获了就按照开发者的处理逻辑选择结束或者继续运行下去。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 44. 给出`3`条你遵循的多线程最佳实践？:star::star::two:
给线程取有意义的名字更好追踪；缩小同步块；`JUC`替代同步集合；

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 45. 什么是`Java`线程转储`(Thread` `Dump)`，如何得到它？:star::star::star::three:
线程转储是一个`JVM`活动线程的列表 ，可以使用`jstack`工具获得； 也可以通过`VisualVM`等工具获得

**题评：** 这个一般是`JVM`调优，使用一些工具来查看栈内存的情况！结合`JVM`学习理解。
::: details 点击查看详细答案
待补充
:::

### 46. 什么是并发容器？:star::star::star::star::four:
并发容器是针对多个线程并发访问设计的，`JUC`包中提供了很多并发容器，如`ConcurrentHashMap`，`CopyOnWriteArrayList`等。并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在`ConcurrentHashMap`中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问`map` 。并发容器比同步容器性能更加好。

**题评：** 不懂还得学习`JUC`，硬背不推荐！一定结合`JUC`来理解！
::: details 点击查看详细答案
待补充
:::

### 47. 什么是原子操作？在`Java` `Concurrency` `API`中有哪些原子类`(atomic` `classes)`？:star::star::star::three:
原子操作是指在多线程环境下避免竞态条件的实现。`JUC`提供了很多原子类，如`AtomicInteger`； `AtomicLong`； `AtomicReference`； `AtomicBoolean`；还有分段锁的`LongAdder`。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 48. `JVM`有哪些不同的线程生命周期|线程状态？:star::star::star::star::three:
- 初始状态：新建线程对象，`start`方法之前
- 运行状态：`start`后，包括就绪态和运行态
- 限时等待：`sleep`、`join`、`wait`方法的超时参数
- 等待状态：调用`wait`、`join`方法
- 阻塞状态（同步状态）：排队竞争锁，等待状态调用`notify`后进入同步状态
- 终止状态：执行完毕或者异常抛出

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 49. 线程之间是如何通信的？:star::star::star::star::three:
`Object`类中`wait()` `notify()` `notifyAll()`方法可以用于线程间通信关于资源的锁的状态。`ReentrantLock` 中是`await()`、`signal()`等；

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 50. 为什么`Thread`类的`sleep()`和`yield()`方法是静态的？:star::star::star::two:
`sleep`，`yield`不涉及到对象锁，只是让线程休眠肯定是要在执行的线程上运行；而`wait`和`notify`是和锁对象相关的，他们的调用都要修改对象头的锁标识，因此是属于`Object`的。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 51. 什么是线程池?:star::star::star::star::star::three:
是指管理一组工作线程的资源池，当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。线程池有下列好处：
- 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- 第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
- 第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控 。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 52. 如何创建线程池?:star::star::star::star::star::four:
- 通过`Executors`工厂类创建，可以创建`newSingleThreadExecuto`只有一条线程的线程池；也可以通过`newFixedThreadPool` 创建固定数量的线程池；`newCachedThreadPool` 创建可缓存线程池，核心线程数是 `0`， 最大线程数是`2`^`29`，全部都是救急线程（`60s` 后可以回收），可能会创建大量线程，从而导致 `OOM`。
- 使用标准构造器`ThreadPoolExecutor`创建线程池，这是大厂推荐的做法，避免上面的阻塞队列爆满无限制放入阻塞的任务导致`OOM`。

**题评：** 无
::: details 点击查看详细答案
- newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
- newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。
- newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
:::

### 53. 线程池的调度流程?:star::star::star::star::star::four:
当提交一个新任务到线程池时，具体的执行流程如下：
`1`. 当我们提交任务，线程池会根据核心线程数`(corePoolSize)`大小创建若干任务数量线程执行任务
`2`. 当任务的数量超过`corePoolSize`数量，后续的任务将会进入任务阻塞队列阻塞排队
`3`. 当阻塞队列也满了之后，那么将会继续创建`(`最大线程数`maximumPoolSize`-`corePoolSize)`个数量的线程来执行任务，如果任务处理完成，`maximumPoolSize`-`corePoolSize`额外创建的线程等待活跃时间`keepAliveTime`之后被自动销毁
`4`. 如果达到`maximumPoolSize`，阻塞队列还是满的状态，那么将根据不同的拒绝策略对应处理

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 54. 什么是上下文切换?:star::star::star::two:
时间片轮转、切换线程是特权指令、内核态切换线程、程序计数器

**题评：** 无
::: details 点击查看详细答案
当前任务在执行完 `CPU` 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态，任务从保存到再加载的过程就是一次上下文切换。
:::

### 55. 如何确定核心线程数量？:star::star::star::star::star::three:
- `IO`密集型：由于`IO`密集型任务的`CPU`使用率较低，导致线程空余时间很多，因此通常需要开`CPU`核心数两倍的线程。
- `CPU`密集型：`CPU`密集型任务虽然也可以并行完成，但是并行的任务越多，花在任务切换的时间就越多， `CPU`执行任务的效率就越低，所以要最高效地利用`CPU`， `CPU`密集型任务并行执行的数量应当等于`CPU`的核心数。
- 混合型任务：混合型任务既要执行逻辑计算，又要进行大量非`CPU`耗时操作，业界有一个比较成熟的估算公式，具体如下：最佳线程数目 =（线程等待时间与线程`CPU`时间之比 + `1`） * `CPU`核数

**题评：** `IO`密集型是两倍主要是不吃`CPU`运行频繁上下文切换，`CPU`密集型不允许`CPU`上下文切换增加`CPU`的压力。
::: details 点击查看详细答案
待补充
:::

### 56. 线程的提交方法？:star::star::star::star::three:
- `submit()` 方法提交任务有返回值，`execute()`无返回值；
- 接受的参数不一样，`execute()`方法只能接收`Runnable`类型的参数，而`submit()`方法可以接收`Callable`、 `Runnable`两种类型的参数。 `Callable`类型的任务是可以返回执行结果的，而`Runnable`类型的任务不可以返回执行结果。
- `submit()`方法自身并不会传递结果，而是返回一个`Future`异步执行实例，处理过程的结果被包装到`Future`实例中，调用者可以通过`Future`.`get()`方法获取异步执行的结果。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 57. 线程池的关闭方法？:star::star::star::four:
优雅地关闭线程池主要涉及的方法有`3`种：
- `shutdown`：是`JUC`提供一个有序关闭线程池的方法，此方法会等待当前工作队列中的剩余任务全部执行完成之后才会执行关闭，但是此方法被调用之后线程池的状态转变为`SHUTDOWN`，线程池不会再接收新的任务。
- `shutdownNow`：是`JUC`提供一个立即关闭线程池的方法，此方法会打断正在执行的工作线程，并且会清空当前工作队列中的剩余任务，返回的是尚未执行的任务。
- `awaitTermination`：等待线程池完成关闭。在调用线程池的`shutdown()`与`shutdownNow()`方法时，当前线程会立即返回，不会一直等待直到线程池完成关闭。如果需要等到线程池关闭完成，可以调用`awaitTermination()`方法。

**题评：** 至少得说出前两种！
::: details 点击查看详细答案
待补充
:::

### 58. 线程阻塞队列（工作队列）？:star::star::star::star::star::four:
- `ArrayBlockingQueue`  
- `LinkedBlockingQueue`  
- `PriorityBlockingQueue`  
- `SynchronousQueue` 
- `DelayQueue`

**题评：** 看着上面的关键词自己说出每个阻塞队列的特点，说出来才是真正掌握的！
::: details 点击查看详细答案
- `ArrayBlockingQueue` 是一个基于数组结构的有界阻塞队列，此队列按 `FIFO`（先进先出）原则对元素进行排序。
- `LinkedBlockingQueue` 一个基于链表结构的无界阻塞队列，此队列按`FIFO` （先进先出） 排序元素，新任务可以被无限制地缓存到该阻塞队列中，直到资源耗尽。
- `PriorityBlockingQueue` 一个具有优先级的无限阻塞队列。 `PriorityBlockingQueue` 也是基于最小二叉堆实现。
- `SynchronousQueue` 一个不存储元素的阻塞队列，每一个生产线程会阻塞到有一个 `put` 的线程放入元素为止。每次`put`时必须被`get`，否则一直阻塞。
- `DelayQueue` 只有当其指定的延迟时间到了，才能够从队列中获取到该元素； `DelayQueue` 是一个没有大小限制的队列； 因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。
:::

### 59. 线程池的拒绝策略？:star::star::star::star::three:
四种拒绝策略：
- `AbortPolicy`：直接丢弃任务，抛出异常，这是默认策略
- `CallerRunsPolicy`：只用调用者所在的线程来处理任务
- `DiscardOldestPolicy`：丢弃等待队列中最旧的任务，并执行当前任务
- `DiscardPolicy`：直接丢弃任务，也不抛出异常

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 60. 为什么不建议使用 `Executors`静态工厂构建线程池？:star::star::star::star::star::three:
大厂的编程规范都不允许使用`Executors`创建线程池，可能阻塞队列中会堆积大量的任务或者创建大量的线程，从而导致`OOM`。而是要求使用标准构造器`ThreadPoolExecutor`创建线程池。自定确定线程的核心数量和最大数量。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 61. 线程池常用参数？:star::star::star::star::star::three:
核心参数：
- `corePoolSize` : 任务队列未达到队列容量时，最大可以同时运行的线程数量。
- `maximumPoolSize` : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- `workQueue`: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。
`ThreadPoolExecutor`其他常见参数 :
- `keepAliveTime`:线程池中的线程数量大于 `corePoolSize` 的为救急线程，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁；
- `threadFactory` :`executor` 创建新线程的时候会用到。
- `handler` :饱和拒绝策略。

**题评：** 核心参数面试必须答出来，补充的其他参数可以选答！
::: details 点击查看详细答案
待补充
:::

### 62. 什么是`ThreadLocal`变量？:star::star::star::star::star::four:
每个线程都有一个私有的`ThreadLocal`，意味着其中的变量不存在共享，彻底避免竞争条件。原理是`Thread`中有一个`ThreadLocalMap`内部类，而`key`为`ThreadLocal`，`value`为存储的值。可以比作`Thread`为人，`ThreadLocalMap`为书包，`ThreadLocal`为书包中的一页纸。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 63. `ThreadLocal`用在什么地方？:star::star::star::star::three:
保存线程的上下文信息，例如在拦截器中可以将用户信息存储在`ThreadLocal`中。如果同步带来的性能损失无法解决业务的情况下可以考虑`ThreadLocal`。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 64. `ThreadLocal`存在的问题？:star::star::three:
`ThreadLocal`是线程隔离的，无法解决共享对象的更新问题，且占用栈内存。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 65. 为什么要调用`remove`方法进行清理?:star::star::star::star::four:
在`ThreadLocalMap`中，`key`是弱引用，可以被垃圾回收；但是`value`是被`entry`强引用所指向的，无法简单被`GC`，在使用`ThreadLocal`时，使用完毕后，配合调用`remove()`，就会清除掉`ThreadLocalMap`中`key`为`null`的`value`。避免内存泄露；

**题评：** 无
::: details 点击查看详细答案
待补充
:::

