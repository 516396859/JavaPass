---
title: 多线程与并发
icon: file
order: 6
author: Ms.Cheney
date: 2023-10-05
category:
    - Java 基础
copyright: 版权声明：本文为JavaPass博主「javapass.cn」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
---

### 多线程的安全问题:star::star::star::star::three:
线程安全指的是：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的，或者说共享数据块每一时刻都只能有一个线程操作。

程序存在线程安全问题的条件：
- 是否是多线程（单线程没有线程安全问题，例如Redis）
- 是否共享数据 (数据不共享一般不会有安全性问题，例如ThreadLocal)
- 是否多个条语句操作共享数据 (主要指的是多线程环境下的写操作，读操作没有安全性问题)

保证多线程安全的方法：只需要将共享数据的代码锁起来，让任意时刻只有一个线程在执行即可。造成多线程安全问题的真正原因：并发环境下`CPU`上下文切换导致指令的交错执行，操作同一数据。也就是上述三个条件。

**题评：** 这个题目很重要哦，一般会结合项目来问！至少以上三点你应该掌握！
::: details 点击查看详细答案
待补充...
:::

### 谈谈`Lock`锁:star::star::star::three:
`Java`还提供了功能更加强大的加锁和释放锁的方法，`Lock`锁不能直接实例化，需要采用它的实现类`ReentrantLock`来实例化，提供了`lock()`加锁和`unlock()`释放锁。`Synchronized`，它是`java`语言的关键字，需要`jvm`实现   ；`ReentrantLock`它是`JDK` `1`.`5`之后提供的`API`层面的互斥锁 ；
- 等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待 ；
- 公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，`Synchronized`锁非公平锁，`ReentrantLock`默认的构造函数是创建的非公平锁，可以通过参数`true`设为公平锁 。
- 锁绑定多个条件，一个`ReentrantLock`对象可以同时绑定多个对象。

**题评：** 谈`Lock`接口，主要要说出它的实现类`ReentrantLock`的原理和特性。
::: details 点击查看详细答案
待补充...
:::

### `ReentrantLock` 是什么？:star::star::star::star::star::three:
`ReentrantLock` 实现了 `Lock` 接口，是一个可重入且独占式的锁，和 `synchronized` 关键字类似。不过，`ReentrantLock` 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。 `ReentrantLock` 的底层就是由 `AQS` 来实现的。

**题评：** `ReentrantLock` 知道这些远远不够，底层`AQS`实现也需要懂，后面会有`AQS`的讲解，但是以上是总结的精华，每一个特性你是否懂，不懂就去学。
::: details 点击查看详细答案
待补充...
:::

### 如何停止一个正在运行的线程:star::star::star::two:
- 使用退出标志`flag`，程序运行结束
- 使用`stop`方法强行终止
- 使用`interrupt`方法中断线程

**题评：** 每种方法的背后需要知道，上面简述只是回答面试官的答案，你需要根据上面的提示说出背后的原理！切记，`JavaPass`不是减轻你的背诵，而是通过简单的答案唤醒你的知识记忆！
::: details 点击查看详细答案
待补充...
:::

### `sleep()`和`wait()` 有什么区别？:star::star::star::star::star::three:
`sleep`方法属于`Thread`类，`wait`方法属于`Object`类。当调用`wait()`方法的时候，线程会放弃对象锁，进入此对象的等待队列中挂起 。只有针对此对象调用`notify()`方法后本线程才进入对象同步队列竞争锁对象。
- `sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁 。
- `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()` 方法。`sleep()`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long` `timeout)` 超时后线程会自动苏醒。
- `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。

**题评：** 以上能说出多少说多少，最好全部能够记住，但是每一个点都需要掌握！
::: details 点击查看详细答案
待补充...
:::

### 为什么 `wait()` 方法不定义在 `Thread` 中？:star::star::star::star::star::three:
`wait` 方法是`Object`的方法，每个对象都有，是让自己释放当前的对象锁并挂起，对象锁是在对象头的`MarkWord`中，重量级锁对象是通过监视器对象实现的，因此当调用`wait`方法就会将当前线程挂起并加入到当前监视器的等待队列中。以上说明与`wait`打交道的都是对象，因此`wait`方法释放锁是操作对象而不是`Tread`类。为什么 `sleep()` 方法定义在 `Thread` 中？因为 `sleep()` 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。

**题评：** 需要理解透彻！很常考！
::: details 点击查看详细答案
待补充...
:::

### 为什么`wait`, `notify` 和 `notifyAll`这些方法不在`thread`类里面？:star::star::star::star::star::three:
`JAVA`提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。上面的答案符合本题！

**题评：** 同上！
::: details 点击查看详细答案
待补充
:::

### 为什么`wait`和`notify`方法要在同步块中调用？:star::star::star::star::star::three:
只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的`wait()`,`notify()`和`notifyAll()`方法。`wait()`方法强制当前线程释放对象锁。这意味着在调用某对象的`wait()`方法之前，当前线程必须已经获得该对象的锁。在调用对象的`notify()`和`notifyAll()`方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的`notify()`或`notifyAll()`方法。

**题评：** 同一类题。
::: details 点击查看详细答案
待补充...
:::

