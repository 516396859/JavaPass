---
title: Redis基础
icon: file
order: 1
author: Ms.Cheney
date: 2023-10-19
PageView: true
lastUpdated: true
category:
    - 中间件
copyright: false
footer: 赣ICP备2023007682 | 使用 <a href="https://theme-hope.vuejs.press/zh/" target="_blank">VuePress Theme Hope</a> 主题 | MIT 协议, 版权所有 © 2023-Cheney,2018-present Mr.Hope
# 版权声明：本文为JavaPass博主「javapass.cn」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
--- 

### 1. `Redis`缓存的优点是什么？:star::star::star::two:
存储在内存，速度快，避免全部访问数据库，多样的数据结构，提供集群和持久化功能保证高并发和高可用。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 2. `Redis`缓存的缺点是什么？:star::star::star::two:
单机内存有限，单线程不能执行阻塞式的操作例如`keys`，虽然有持久化机制但是依旧存在数据丢失，并且可能性比`MySQL`要高。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 3. 为什么`Redis`单线程效率也很高？:star::star::star::star::three:
- `C`语言编写、单线程避免上下文切换、基于内存的数据库、丰富的数据结构；
- `I`/`O`多路复用技术：多路-指的是多个 `socket`网络连接，复用-指的是复用一个线程。 多路复用主要有三种技术：`select`，`poll`，`epoll`。  采用多路 `I`/`O` 复用技术,可以让单个线程高效处理多个连接请求（尽量减少网络 `IO` 的时间消耗）

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 4. `Redis`分布式锁原理了解吗？:star::star::star::star::two:
`setnx`命令争抢锁、并使用`expire`指令设置过期时间，这两条命令最好在一条命令中。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 5. `Redis`的同步机制了解吗？:star::star::star::star::three:
在主从同步时保证数据一致性，分为两个主要的步骤全量复制和部分复制两个过程。全量复制通过`bgsave`命令保存`RDB`缓存传输，部分复制是复制缓冲区的命令。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 6. `pipeline`管道机制的好处？:star::star::star::four:
`Redis`客户端发送一次命令，服务器需要一次`IO`，每次命令执行完成才能执行下一个命令；使用`pipeline`管道可以一次提交多个命令，缩短为一次`IO`，客户端只需要最后一步从服务器读取处理结果就好。提高执行效率，前提是指令之间没有因果关系。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 7. `Redis`的缓存过期删除策略?:star::star::star::star::three:
- 定期删除和懒惰删除：定期删除是每隔`100ms`就轮询访问一个卡槽，进行随机抽样如果过期占比超过`25`%就进行删除过期，否则跳过轮询下一个；权衡了`CPU`压力和内存压力；
- 惰性删除：过期了不删除等到用的时候进行判断是否过期了，好处是节省`CPU`性能，坏处是内存压力过大。
- 定时删除：只要`TTL`到了`0`就立即删除。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 8. 缓存淘汰策略了解吗？:star::star::star::star::three:
对于设置了过期时间的易失数据：
- `LRU`：淘汰最近不常用的数据，实现算法是`LinkedHashMap`，新数据放在链表头，不常用的数据放在链表尾；使用时间戳作为权重。
- `LFU`：淘汰最近使用频率最少的，使用次数作为权重；
- `TTL`：淘汰将要过期的数据；
对于全库检测：
- `LRU`：淘汰最久使用的
- `LFU`：淘汰使用频率最低的
- `Random`：随机删除

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 9. `Redis`持久化方式及其区别？:star::star::star::star::three:
- `RDB`，数据库快照持久化，每隔一段时间使用子线程进行持久化，适合数据要求不严格的场景。二进制形式保存，文件小，恢复速度快，适合全量复制。
- `AOF`，每次命令都追加到`AOF`文件中。保存命令指令，文件更大，恢复速度慢，但是可以保证数据一致性。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 10. `RDB`的一些基础命令了解吗？:star::star::star::three:
阻塞式保存快照 `sava`，子线程保存快照 `bgsave`；   `save` `60` `100` ，一分钟内修改了`100`次就触发快照保存；`scan` 可以异步快速查找符合规则的键，而`keys`是通过同步的方式阻塞式查找符合规则的键。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 11. `AOF`有安全性问题吗？ | `AOF`的刷盘机制策略了解吗？:star::star::star::four:
有，当指令追加到`AOF`文件中并不是立即刷盘到硬盘，而是先存入到操作系统缓冲区中。如果这时宕机了就丢失了数据，因此提供了三种策略：
- `always`：每次修改就立即写入`AOF`文件，最多丢失一个事件循环的数据
- `everysec`：每隔一秒写入`AOF`文件，最多丢失一秒数据
- `no`：以操作系统刷盘时间决定，丢失不可控

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 12. `AOF`文件过大恢复时间过长怎么办？:star::star::star::three:
`AOF`文件会定期重写，对`AOF`文件进行压缩；`AOF`重写就是把无效的指令取出，例如过期的指令、被覆盖的指令、被删除的指令等。保证结果是幂等性的，重写`AOF`文件是读取`redis`内存中的数据重写`AOF`文件。新的指令保存在缓存中，等重写完后合并。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 13. 持久化的两种方式如何选择？:star::star::star::star::three:
- 非重要的数据：`RDB`，启动快，占用小
- 重要数据：`RDB`+`AOF`，`RDB`做冷备份，优先使用`AOF`恢复

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 14. 如何使用`Redis`实现消息队列？:star::star::three:
使用`list`数据结构，`blpop`和`brpush`命令阻塞式消费和生产数据；可以使用`pub`/`sub`主题订阅模式实现`1`对多的消息队列，但是消费者下线了会导致生产的消息丢失。要实现延时队列可以使用`sortedSet`，使用时间戳作为`score`，消息内容为`key`调用`zadd`生产消息，消费者使用`zrangebyscore`指令获取前`N`秒数据轮询处理。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 15. `Redis`的事务了解吗？:star::star::star::three:
`redis`中事务是一组`redis`命令组成的集合，使用`MULTI`命令开启一个事务，`EXEC`按照顺序执行事务中所有的命令。需要注意的是`Redis`事务不支持回滚，如果是语法错误`Redis`事务会执行失败，如果是其他错误则正确的指令依旧会执行。不支持回滚可以保证简单快速的特点。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 16. 为什么`Redis`选择了单线程？:star::star::star::three:
避免上下文切换；多线程涉及到线程安全性问题，需要加锁保证线程安全；

**题评：** 无
::: details 点击查看详细答案
只有网络请求模块和数据操作模块单线程，持久化模块和集群模块等是多线程（在后台清理数据、扫描查询）。多线程的目的：提升CPU和I/O的利用率，CPU不是Redis的瓶颈，而I/O采用多路复用技术解决，所以没必要在网络请求和数据操作模块设计多线程。在`Redis6`中也将网络请求模块改成了多线程，为了利用多核CPU提高IO处理能力。
:::

### 17. 什么是非阻塞`IO`多路复用？:star::star::star::four:
客户端通过`socket`请求`redis`，不同操作也称为不同事件，`IO`多路复用程序监听多个`socket`，将产生的事件放入队列中排队，然后事件分派器从队列中取出根据事件类型交给事件处理器处理。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 18. 什么是`BigKey`？还存在什么影响?:star::star::three:
`bigkey` 就是存储的`value`太大了，例如存了一个二机制文件`200M`，这会造成网络传输阻塞和`IO`阻塞，也会导致内存空间不平衡。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 19. 集群的作用了解吗？:star::star::star::two:
- 提高并发量，负载均衡，减轻单个服务器的压力
- 提高可用性，提高容灾能力，降低单台服务器宕机风险

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 20. `Redis`的集群模式有哪些？:star::star::star::three:
- `Sentinel`  ：体量较小时，选择 `Redis` `Sentinel` ，单主 `Redis` 足以支撑业务 。
- `Cluster`  ： `Redis` 官方提供的集群化方案，体量较大时，选择 `Redis` `Cluster` ，通过分片，使用更多内存。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 21. 说说`Redis`哈希曹的概念？:star::star::star::star::three:
`Redis` 集群并没有使用一致性 `Hash`，而是引入了哈希槽的概念。`Redis` 集群有 `16384`（`2`^`14`）个哈希槽，每个 `key` 通过 `CRC16` 校验后对 `16384` 取模来决定放置哪个槽，集群的每个节点负责一部分`Hash` 槽。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 22. 主从复制的流程知道吗？|什么是主从复制？:star::star::star::four:
`1`. `slave` 向 `master` 发送 `SYNC` 命令请求启动复制流程； 
`2`. `master` 收到 `SYNC` 命令之后执行 `BGSAVE`命令（子线程执行，不会阻塞主线程）生成 `RDB` 文件（`dump`.`rdb`）；
`3`. `master` 将生成的 `RDB` 文件发送给 `slave`；
`4`. `slave` 收到 `RDB` 文件之后就开始加载解析 `RDB` 同步更新本地数据；
`5`. 更新完成之后，`slave` 的状态相当于是 `master` 执行 `BGSAVE` 命令时的状态。`master` 会将 `BGSAVE` 命令之后接受的写命令缓存起来，因为这部分写命令 `slave` 还未同步；
`6`. `master` 将自己缓存的这些写命令发送给 `slave`，`slave` 执行这些写命令同步 `master` 的最新状态；注意如果是断网重连：如果 `master` 发现 `slave` 缺少的数据自己刚好缓存了的话，就会直接发给 `slave`。如果没有的话，那就没办法了，还是要进行全量同步操作
`7`. `slave` 到这个时候已经完成全量复制，后续会通过和 `master` 维护的长连接来进行命令传播，同步最新的写命令。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 23. 部分复制的工作流程知道吗？:star::star::star::star::four:
也就是命令传播阶段，三个重要参数，偏移量`offet`、运行`ID`、缓冲区，从节点将`offset`发送给主节点后，主节点根据`offset`和缓冲区大小决定能否执行部分复制：
- 如果`offset`偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；
- 如果`offset`偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制
在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给积压缓冲区，作为写命令的备份； 当主从节点之间网络出现中断时，如果超过了 `repl`-`timeout` 时间，主节点会认为从节点故障并中断复制连接。这期间无法同步命令到从节点，直到从节点网络恢复再次请求主节点：
- 由于从节点之前保存了自身已复制的偏移量和主节点的运行`ID`。因此会把它们作为 `psync` 参数发送给主节点，要求进行补发复制操作
- 主节点核对运行`ID`和偏移量是否和自身一致，一致则根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。 

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 24. `AOF` 工作基本流程是怎样的？:star::star::four:
- 命令追加：将命令追加到`AOF`缓存区。
- 文件写入：`AOF`缓存区数据写入到系统内核缓冲区。
- 文件同步：将缓冲区中数据刷盘到硬盘中。
- 文件重写：随着`AOF`变大，需要定时重写压缩`AOF`；
- 启动加载：当 `Redis` 重启时，可以加载 `AOF` 文件进行数据恢复。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 25. 为什么`Redis`操作是原子性的？:star::star::star::three:
因为`Redis`是单线程的，`Redis`本身提供的`API`操作都是原子操作，而`Redis`的事务是要保证批量操作的原子性。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 26. 缓存雪崩、缓存穿透、缓存击穿、缓存预热、缓存更新、缓存降级等问题了解吗？:star::star::star::star::three:
- 缓存雪崩：很多缓存同时过期，导致很多缓存失效从而访问数据库。解决方法：设置不同的失效时间，多级缓存，熔断降级。
- 缓存穿透：`Mysql`数据库中不存在的一些数据被频繁访问，是一种攻击手段，防御方法是缓存`null`值和布隆过滤器，或者考虑加锁；
- 缓存击穿：缓存击穿是单个超级热点数据被大量访问，而这个热点数据没有缓存，导致全都访问到了数据库上；解决办法是逻辑过期，或者设置超热数据不过期；
- 缓存降级：当访问量剧增的话，保证核心服务可用，对不重要的数据不缓存直接返回空值。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 27. 如何保证本地缓存和分布式缓存的一致性？:star::star::star::star::four:
- 本地缓存和分布式缓存通过加锁达到同步修改，严格保证一致性，但是效率非常低。
- 事件驱动一致性： 当数据在后端数据源中被修改时，可以发布一个事件，通知所有缓存节点更新对应数据。本地缓存和分布式缓存可以通过订阅这些事件来保持一致。一般使用阿里的`Canel`中间件实现。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 28. 如何保证缓存与数据库的双写一致性？:star::star::star::star::four:
读的时候先读缓存，缓存没有再读数据库。
写的时候先更新数据库，再删除缓存；
- 不更新缓存是因为可能频繁修改这个字段，但是却不读取，导致频繁更新缓存却不读缓存，懒加载节省性能。
- 为什么不先删除缓存再更新数据库？删除缓存很快，更新数据库很慢，万一大量请求发现缓存不在而去读取数据库，此时数据库还没有更新完毕，则读到旧数据放在缓存上。另外，可能导致`mysql`击穿。其实先更新数据库再删除缓存也会导致数据一致性问题，例如删除缓存失败。只是概率低一点；
- 保证强一致性的话只能将更新缓存和更新数据库进行加锁同步。但这会影响高并发和高可用性。
使用消息队列（`canal`）的重试机制保证删除对应的`key`。延时双删，先删缓存，如果更新数据库期间脏读了旧数据，最后更新完数据库还会进行一次删除缓存。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 29. 热`key`如何处理？:star::star::star::three:
- 最重要就是监控热点`key`，通过`monitor`命令统计热点`key`
- 对热点`key`分散到不同的服务器，降低压力
- 加入`JVM`本地缓存，提前预热热点`key`
- 使用逻辑过期，当过期了返回过期值，新建一个线程去查找新的数据

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 30. `Redis`内存不足怎么办？:star::star::star::four:
- 修改配置文件，增加`redis`可用内存
- 修改内存淘汰策略，及时释放空间
- 使用`Redis` `Cluster`集群，增加物理机器

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 31. 哪些情况会发生`Redis`阻塞？:star::star::star::star::three:
- 操作大`key`，例如删除大`key`
- 使用阻塞命令，`keys`，`save`
- `AOF`刷盘阻塞，硬盘压力大时，需要等待。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 32. `redis` 的并发竞争问题是什么？:star::star::four:
`Redis`并发竞争是多个客户端并发写一个`key`，本来应该是先到的请求先写`key`，但可能由于网络环境差异，先发起的请求后到了，导致`value`最终被后发起的请求修改，最终数据错乱了。或者是多个客户端同时获取一个`key`，修改值后再写回去，只要顺序错了，数据纠错了。解决方案是使用分布式锁、`CAS`乐观锁。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 33. `redis`中的布隆过滤器?:star::star::four:
创建布隆过滤器，`bf.reserve userid 0.01 1000000` 创建`userid`过滤器，给定错误率，数据大小。自动创建布隆过滤器，可以使用命令`add`添加，`exists`命令查询是否存在某个值。`redis` 的 `bf` 需要去`github`上面下载配置。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 34. `Redis` 如何解决 `key` 冲突？:star::star::one:
如果两个`key`名字一样，后一个会覆盖前一个，因此需要按照不同的业务和参数使用：区分开，避免冲突。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 35. 怎么提高缓存命中率？:star::star::star::three:
- 提前加载数据到缓存中
- 增加缓存存储空间，提高缓存数据量

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 36. 什么情况下可能会导致 `Redis` 阻塞？:star::star::star::three:
- 外部原因：服务器`CPU`、内存满载、网络出现问题
- 内部原因：持久化占用资源过多，使用阻塞式命令 `save` `keys`

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 37. 假如 `Redis` 里面有`100`万个`key`，其中有 `1w` 个 `key` 是以某个固定的已知的前缀开头的，如果将它们全部找出来？:star::star::star::four:
使用`scan`的`match` `key`* 匹配出来，使用`keys`会导致线程阻塞，`scan`使用子线程去查找，相对来说会花费更多的时间但不阻塞`Reids`主线程。

**题评：** 无
::: details 点击查看详细答案
待补充
:::


### 38. `Redis`过期时间怎么设置，`Redis`怎么续期?:star::star::star::three:
`EXPIRE mykey 60`，也可以使用`setex name cj 60`，通过`ttl kye`获取剩余过期时间，通过`expire key time`重设过期时间。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 39. `Redis`数据类型知道哪些？:star::star::star::star::three:
- `5` 种基础数据结构：`String`（字符串）、`List`（列表）、`Set`（集合）、`Hash`（散列）、`Zset`（有序集合）。
- `3` 种特殊数据结构：`HyperLogLogs`（基数统计）、`Bitmap` （位存储）、`Geospatial` `(`地理位置`)`。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 40. 如何找到大`key`？:star::star::two:
使用 `bigkeys` 命令

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 41. `redis`如果一个`key`特别大，如果要删除掉会有什么问题，比如删除一个特别大的 `ZSet`，怎么删？:star::star::star::three:
`key`太大了，删除时间很长会导致单线程阻塞。可以分批进行删除，例如每次获取`500`个字段进行删除。新的版本可以使用`unlink`异步删除，删除操作时在后台进行的。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 42. `Redis`异步队列知道吗？:star::star::three:
主要是使用`list`的`blpop`和`brpush`两个指令；

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 43. `Redis` 除了做缓存还能做什么？:star::star::star::two:
分布式锁、消息队列、排行榜、签到、统计访问量

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 43. `String` 还是 `Hash` 存储对象数据更好呢？:star::star::star::four:
`String` 存储的是对象序列化后的数据，或者存储`json`数据；`Hash`是存储对象的每个字段；`String`节省内存，但是`Hash`可以修改对象；

**题评：** 这里是否更加节省内存是有争议的，后面会确认！
::: details 点击查看详细答案
待补充
:::

### 44. 购物车信息用 `String` 还是 `Hash` 存储更好呢?:star::star::three:
由于购物车中的商品频繁修改和变动，购物车信息建议使用 `Hash` 存储：
- 用户 `id` 为 `key`
- 商品 `id` 为 `field`，商品数量为 `value`

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 45. 使用 `Redis` 实现一个排行榜怎么做？:star::star::star::three:
`Redis` 中有一个叫做 `sorted` `set`  `zset`的数据结构经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 46. 使用 `Set` 实现抽奖系统怎么做？:star::star::three:
`spop` `key` `count` ：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 47. 使用 `Bitmap` 统计活跃用户（签到）怎么做？:star::star::three:
以月为`key`，例如`key`为`202306`:`user1`，``setbit` `key`  `index`  `value``，``setbit` `202306`:`user1` `0` `1``第一天签到 ，``bitcount` `202306`:`user1` ` 获取`1`的数量。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 48. `RDB` 创建快照时会阻塞主线程吗？:star::star::star::three:
使用`save`命令会，使用`bgsave`会使用子线程不会阻塞主线程。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 49. 什么是 `AOF` 持久化？:star::star::star::three:
`AOF` 持久化的实时性更好，开启 `AOF` 持久化后每执行一条会更改 `Redis` 中的数据的命令，`Redis` 就会将该命令写入到 `AOF` 缓冲区。默认情况下 `Redis` 没有开启 `AOF`（`append` `only` `file`）方式的持久化（`Redis` `6`.`0` 之后已经默认是开启了），可以通过 ``appendonly`  `yes`` 参数开启：

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 50. `AOF` 为什么是在执行完命令之后记录日志？:star::star::three:
避免额外的检查开销，`AOF` 记录日志就不会对命令进行语法检查；在命令执行完之后再记录，不会阻塞当前的命令执行。但是也有风险：如果刚执行完命令 `Redis` 就宕机会导致对应的修改丢失；而且可能阻塞后面的命令。（`aof`是主线程记录日志）

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 51. `AOF` 校验机制了解吗？:star::star::three:


**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 52. `Redis6`.`0` 之后为何引入了多线程？:star::star::three:
`Redis6`.`0` 引入多线程主要是为了提高网络 `IO` 读写性能，因为这个算是 `Redis` 中的一个性能瓶颈（`Redis` 的瓶颈主要受限于内存和网络）。但是 `Redis` 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 53. `Redis` 单线程模型了解吗？:star::star::star::four:
`Redis` 基于 `Reactor` 模式设计开发了一套高效的事件处理模型（`Netty` 的线程模型也基于 `Reactor` 模式）。通过 **`IO` 多路复用程序** 来监听来自客户端的大量连接。：`I`/`O` 多路复用技术的使用让 `Redis` 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗（和 `NIO` 中的 ``Selector`` 组件很像）。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 54. `Redis6`.`0` 之前为什么不使用多线程？:star::star::three:
纠正一下，`6`.`0`之后也是单线程的，只不过是网络`IO`读写是多线程了，因为单线程更加容易维护，没有上下文切换性能更高，`Redis`的瓶颈不在`CPU`主要在网络和内存。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 55. `Redis` 后台线程了解吗？:star::star::four:
- `close`_`file` 后台线程来释放 `AOF` / `RDB` 等过程中产生的临时文件资源。
- `aof`_`fsync` 后台线程调用 ``fsync`` 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（ `AOF` 文件）。 
- `lazy`_`free`后台线程释放大对象（已删除）占用的内存空间. 

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 56. `Redis` 是如何判断数据是否过期的呢？:star::star::three:
`Redis` 通过一个叫做过期字典（可以看作是 `hash` 表）来保存数据过期的时间。过期字典的键指向 `Redis` 数据库中一个 `long` `long` 类型的整数。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 57. 如何发现和解决 `hotkey`？:star::star::three:
使用命令 `hotkeys`查找，借助第三方京东零售的`hotkey`插件查找；分散`hotkey`到不同服务器，读写分离，使用集群分散压力，二级缓存将`hotkey`缓存在本地`JVM`缓存中。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 58. 为什么主从全量复制使用 `RDB` 而不是 `AOF`？:star::star::star::three:
- `RDB` 文件存储的内容是经过压缩的二进制数据，文件很小。传输 `RDB` 文件更节省带宽，速度也更快。
- 使用 `RDB` 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。
- `AOF` 需要选择合适的刷盘策略，如果刷盘策略选择不当的话，会影响 `Redis` 的正常运行。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 59. 主从复制下从节点会主动删除过期数据吗？:star::star::star::four:
- 客户端读从库会先判断数据是否过期，如果过期的话，就会删除对应的数据并返回空值。主从复制的过程中，从节点是不能向主节点发送任何命令的，所有的数据都是主动推送到从节点。因此在 `Redis` 主从复制机制中，过期键的过期处理完全由主节点来执行，主节点会在自身的内存中删除过期键，并向所有从节点发送删除指令，从节点会在处理完主节点的删除指令后删除自己的过期键。从节点在读取数据时，增加了对数据是否过期的判断：如果该数据已过期，则不返回给客户端；
- 对于过期键的过期时间，主从节点之间的缓存时间差异是一定存在的，但只要在合理的时间周期内进行同步，应用程序既可以自行判断失效的键是否存在，避免读取无用的过期键。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 60. 缓存更新为什么删除 `Redis`，而不是更新 `Redis`？:star::star::star::star::three:
- 采用懒加载方式避免内存空间的浪费
- 高并发更新`Redis`可能产生数据不一致问题

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 61. 在写数据的过程中，可以先删除 `Redis`，后更新数据库么？:star::star::star::star::three:
不行的！因为这样可能会造成 数据库和缓存数据不一致的问题。因为删除了`Redis`，后面的线程从数据库读取数据是旧的数据，而更新数据库时间更长；如果非要这样做那只能进行延迟双删了。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 62. 在写数据的过程中，先更新数据库，后删除 `Redis` 就没有问题了么？:star::star::star::star::three:
理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 63. `Redis`的数据结构及其实现?:star::star::four:
待补充。。。

**题评：** 暂无
::: details 点击查看详细答案
待补充
:::
