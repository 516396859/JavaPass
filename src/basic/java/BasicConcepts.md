---
title: 基本概念
icon: file
order: 1
author: Ms.Cheney
date: 2023-10-05
PageView: true
lastUpdated: true
category:
    - Java 基础
copyright: false
footer: 赣ICP备2023007682 | 使用 <a href="https://theme-hope.vuejs.press/zh/" target="_blank">VuePress Theme Hope</a> 主题 | MIT 协议, 版权所有 © 2023-Cheney,2018-present Mr.Hope
# 版权声明：本文为JavaPass博主「javapass.cn」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
---


::: tip 
- :star: 越多表示题目出现的频率较高，建议重点掌握。
- :one: :two: :three: :four: :five: 数字越大表示题目的难度系数越高，建议结合:star:情况进行选择。
- 如果题评说了必知必会，那么无论是否频率低请一定要记住，否则面试效果大打折扣。
:::

### 1. Java 语言的基本特点? :star: :one:
- 面向对象（封装，继承，多态）；
- 平台无关性（ `Java` 虚拟机实现平台无关性）；
- 编译与解释并存 ( `.java`文件编译成字节码 `.class`，解释器对字节码进行解释运行)；
- 支持多线程 (`C++、Python` 语法层面不支持多线程)；

**题评：** 此题不难，属于必知必会的知识点，中大厂基本不会问，银行和一些微小厂可能会问到。属于答出来了不加分，答不出来直接挂的题目。记忆关键词即可，然后按照自己的理解展开括号中的内容即可。可以自我发挥，但围绕这几个关键词展开即可，一定记住前面两个关键词，后两个尽量记住。

::: details 点击查看详细答案
Java 语言是一种面向对象的语言，它的三个主要特点是：封装、继承、多态。Java 语言的最具特色的地方就是它的平台无关性，也就是说，Java 语言编写的应用程序在不同的系统平台上都可以运行。Java 语言是一个编译与解释并存的语言，Java 语言编写的程序首先被编译成字节码，然后由 Java 解释器对字节码进行解释运行。Java 语言支持多线程，这对于实现高性能程序很重要。
:::

### 2. JVM 、 JDK 和 JRE 的区别? :star::star: :one:
- `JVM` 是 `Java` 虚拟机，`JRE` 是 `Java` 运行环境，`JDK` 是 `Java` 开发工具包。
- `JVM` 最小，`JRE`包括`JVM`和核心类库，`JDK`包括`JRE`和开发工具`(jar、javadoc、javac)`。

**题评：** 此题必知必会题。记忆技巧按照上面两点记忆，首先回答是什么，然后回答什么关系。详细请参考下面答案！
::: details 点击查看详细答案
- `JVM（Java Virtual Machine）：JVM `是 `Java `虚拟机的缩写，是 `Java`运行时环境的一部分。`JVM` 是一个虚拟的计算机环境，它在实际计算机上模拟执行 `Java` 字节码（`Java` 编译后的中间代码）。负责将字节码翻译成特定计算机架构的机器代码，并执行 `Java` 程序。只要使用到了`Java`语言，就一定会涉及到 `JVM`。
- `JRE（Java Runtime Environment）：JRE` 是 `Java` 运行时环境的缩写，用于运行 `Java` 应用程序。`JRE` 包含了 `JVM` 和运行 `Java` 应用程序所需的 `Java` 类库。当用户要运行 `Java` 应用程序时，他们只需要安装 `JRE`，而不需要安装 `JDK`。而当用户想要开发 `Java` 应用程序时，他们就需要安装 `JDK`。
- `JDK（Java Development Kit）：JDK `是 `Java` 开发工具包的缩写，用于开发 `Java` 应用程序。`JDK` 包含了 `Java` 编译器`（javac）`、`Java` 开发工具（如 `javadoc、jar、debugger` 等）、`Java` 类库（`Java API`）、以及一个 `JRE`（`Java` 运行时环境）。开发人员使用 `JDK` 来编写、编译和调试 `Java` 代码。
:::

### 3. 什么是字节码?采用字节码的好处是什么? :star::star: :one:
- 字节码是一种中间状态，介于源码和机器码之间的代码，字节码文件是以`.class` 结尾的文件。
- 好处：跨平台；性能优化；安全性高；
- 缺点：执行速度慢；占用更多的内存。(以防被回首掏)

**题评：** 此题必知必会题。同样的套路，首先回答是什么，再已知原理的情况下，很快能够想到好处和缺点。这就需要你提前看过一些更加详细的八股文，例如JavaGuide。

::: details 点击查看详细答案
在 `Java` 中，`JVM` 可以理解的代码就叫做字节码（即扩展名为 `.class` 的文件）只面向虚拟机。由于字节码并不针对一种特定的机器，因此，`Java` 程序无须重新编译便可在多种不同操作系统的计算机上运行。注意的是 `.class->机器码` 这一步。在这一步 `JVM` 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 `JIT（just-in-time compilation）` 编译器，而 JIT 属于运行时编译。当 `JIT` 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 `Java` 解释器的。这也解释了我们为什么经常会说 `Java` 是编译与解释共存的语言。
以上答案来自`JavaGuide`，著作权归`JavaGuide(javaguide.cn)`所有,基于MIT协议,原文链接：https://javaguide.cn/java/basis/java-basic-questions-01.html
:::

### 4. 为什么说 Java 语言“编译与解释并存”? :star::star: :one:
- `Java` 语言是编译与解释共存的语言，`Java` 语言编写的程序首先被编译成字节码，然后由 `Java` 解释器对字节码进行解释运行。
- 并且使用了`JIT（just-in-time compilation）`对热代码进行运行时编译，提高运行效率。


### 5. 基本类型和包装类型的区别? :star::star: :one:
- 存储方式、占用空间、默认值、比较方式
::: details 点击查看详细答案
- 存储方式 ：基本数据类型的局部变量存放在 `Java`虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 `static` 修饰 ）存放在 `Java` 虚拟机的堆中。包装类型属于对象类型，几乎所有对象实例都存在于堆中。
- 占用空间 ：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。
- 默认值 ：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。
- 比较方式 ：对于基本数据类型来说，`==` 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 `equals()` 方法。
:::

### 6. 基本移位运算符? :star: :one:
- `<<` 固定符号位左移运算符，`num << 1`,相当于`num`乘以`2，-1 << 1 = -2`
- `>>` 固定符号位右移运算符，`num >> 1`,相当于num除以`2，-4 >> 1 = -2`
- `>>>` 右移运算符，符号位也会移动，空位都以0补齐，`-4 >>> 1 = 2147483646`

### 7. 介绍 Java 各种基本数据类型?
- 记忆顺序： `byte、short、int、long、float、double、char、boolean`。
- 所占字节大小分别是 `1、2、4、8、4、8、2、1` 个字节。
:::tip 记忆要诀
`byte` 是1字节，一直到`long` 8 字节不断翻倍。然后记住`float` 和 `int` 都是4字节，`double` 和 `long` 都是8字节。`char` 是2字节，`boolean` 不到1字节，一位即可。1字节等于8位，所以 `int` 有32位能够表达的数据范围是 `-2^31 ~ 2^31-1` 。
:::

### 8. 包装类型的常量池技术|自动装箱的缓存机制?
- 缓存机制只针对包装类型，不包括基本数据类型，调用`XXX.valueof`装箱(自动装箱)的时候，避免频繁地`new Integer()`等，而是小范围内的包装类型直接从缓存中获取。`Byte,Short,Integer,Long` 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据， `Character` 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False  。两种浮点数类型的包装类 `Float,Double` 并没有实现常量池技术 。因此，使用包装类型的常量池中的对象都是相同的对象。

```java
Integer i1 = 40; //自动装箱，隐式调用Integer.valueOf(40)，得到缓存中的对象
Integer i2 = new Integer(40);// 创建的新对象
System.out.println(i1==i2); // 直接用==号，比较的是对象地址，结果为：false
```

### 9. 为什么要有包装类型?
- 接住`Null`值，基本数据类型无法接住`Null`值，而包装类型可以。
- 泛型，泛型只能接受引用类型，不能是基本数据类型，所以需要包装类型。 
- 集合，集合中不能存放基本数据类型，只能存放包装类型。
::: details 点击查看详细答案
- 包装类型初始值可以是`null`值，基本数据类型初始值有默认值且不能为`null`，这在`SQL`查询返回整型时候可能会返回`null`，而用基本数据类型来接返回值可能在会发送空指针异常(自动装箱时调用`null.valueof()`)。
- 例如`ArrayList，HashSet`等数据结果都是接受的是包装类型，这是因为包装类型都是`Object`的子类，所以才能使用泛型。
:::

### 10. Java 方法是值传递还是引用传递?
- Java任何时候都是值传递，当传递对象时，传递的是对象的引用的值，也就是地址。
- 当传递基本数据类型时，传递的是基本数据类型的值。
- 补充：`swap(int a,int b)` 交换两个基本数据类型的值，是不行的，因为传递的是值，不是引用。`swap(Integer a,Integer b)` 交换两个包装类型的值，是可以的，因为传递的是引用的值，也就是地址。无论`int`还是`Integer`，都是值传递，只不过`Integer`是引用类型，传递的是引用的值，也就是地址。

### 11. 什么是自动拆箱、装箱?

```java
Integer in = 10; //装箱:装箱其实就是调用了包装类的Integer.valueOf(10)方法
int n = in; //拆箱:拆箱其实就是调用了 in.intValue()方法。注意如果 in 为null将发生NullPointerException异常。
```

### 12. 为什么浮点数运算的时候会有精度丢失的风险?
- 浮点数在计算机中是以二进制的形式存储的，而二进制无法精确表示十进制小数，所以会有精度丢失的风险。
- 十进制下的 0.2 就没办法精确转换成二进制小数：0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数或者小数部分为0为止。

### 13. 如何解决浮点数运算的精度丢失问题?
- 如果非要使用基本数据类型例如double，那么需要使用指定一个误差范围，然后在比较的时候，两个数的差值小于这个误差范围，就认为这两个数相等。
- 建议直接使用`BigDecimal`类并，然后讲一下`BigDecimal`类原理；
::: details 点击查看详细答案
- `BigDecimal` 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 `BigDecimal` 来做的。`BigDecimal` 的实现利用到了 `BigInteger` （用来操作大整数）, 所不同的是 `BigDecimal` 加入了小数位的概念。`BigInteger` 内部使用 `int[]` 数组来存储任意大小的整形数据。相对于常规整数类型的运算来说，`BigInteger` 运算的效率会相对较低。
- `BigDecimal`类型的变量比较大小使用`compareTo()`方法，`equals()` 方法不仅仅会比较值的大小`（value）`还会比较精度`（scale）`，而 `compareTo()`方法比较的时候会忽略精度。
:::
### 14. 超过Long类型的数据如何存储?
- 使用`BigInteget`存储；`BigInteger` 内部使用 `int[]` 数组来存储任意大小的整形数据。

### 15. 重写与重载?
- 重载：同一个类中，方法名相同，参数列表不同，与返回值无关。
- 重写：子类重写父类的方法，方法名相同，参数列表相同，返回值相同或者是子类的返回值是父类返回值的子类。

### 16. 成员变量与局部变量的区别?
定义的位置不同、默认值不同、内存中的位置不同、生命周期不同。
::: details 点击查看详细答案
- 定义的位置不同：成员变量在局部代码块之外；局部变量在局部代码块中；
- 内存中的位置不同：成员变量对象可以被`static`修饰—属于类的——存放在运行时常量池中（堆中），不被`static`修饰的对象—存储在堆中；局部变量不能被`static`修饰—存储在栈内存的局部变量表中。
- 生命周期不同：成员变量是对象（类）的一部分，随着对象创建（类）而创建销毁而销毁；局部变量随着方法调用结束而结束；
- 默认值不同：一般讨论基本数据类型和包装类对象，成员变量有默认值，局部变量需要赋值；数组局部变量也有默认值！
:::

### 17. 静态变量static修饰?
它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。通常情况下，静态变量会被 `final` 关键字修饰成为常量。

### 18. 静态方法为什么不能调用非静态成员?
静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

### 19. 面向对象三大特征?
- 封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式。
- 继承：子类继承父类的属性和方法。
- 多态：父类引用指向子类对象，`Animal dog = new Dog()`。
::: details 点击查看详细答案
- 封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法get()、 set()来操作属性。 
- 继承，不同类型的对象，相互之间经常有一定数量的共同点。
关于继承如下 3 点请记住： 
a. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。
b. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
c. 子类可以用自己的方式实现父类的方法（重写）。
- 多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。
多态的特点: 
a. 对象类型和引用类型之间具有继承（抽象类）/实现（接口）的关系；
b. 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；
c. 多态不能调用“只在子类存在但在父类不存在”的方法；
d. 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。
:::

### 20. 接口和抽象类有什么共同点和区别?:star::star::one:
**共同点** ：
- 都不能被实例化。
- 都可以包含抽象方法。
- 都可以有默认实现的方法（`Java 8` 可以用 `default` 关键字在接口中定义默认方法）。

**区别** ：
- 接口主要用于对类的**行为进行约束**，你实现了某个接口就具有了对应的行为。抽象类主要**用于代码复用，强调的是所属关系**。
- 一个类只能继承一个类，但是可以实现多个接口。
- 接口中的成员变量只能是 `public static final` 类型（常量）的，不能被修改且必须有初始值，而抽象类的成员变量默认 `default`，可在子类中被重新定义，也可被重新赋值。

**题评：** 必知必会题型
::: details 点击查看详细答案
暂无
:::

### 21. 为什么要有` HashCode`？:star::star::star::two:
`HashCode`的作用：将对象的内存地址映射得到哈希码。在`HashSet`、`HashMap`中会先计算对象的 `hashCode`值来判断对象加入的位置，然后判断是否有相同的`HashCode`重复出现，如果没有则加入操作成功。否则使用`equals`来判断`hashCode`相等的对象属性是否真的相同，如果不同就会重新散列到其他位置，这样我们就大大减少了`equals`的次数，相应就大大提高了执行速度

**题评：** 必知必会题型
::: details 点击查看详细答案
暂无
:::

### 22. 那为什么 `JDK` 还要同时提供`HashCode`和`equals`这两个方法呢？:star::star::star::two:
这是因为在一些容器（比如 `HashMap`、`HashSet`）中，有了 `HashCode()` 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进`HashSet`的过程）！

**题评：** 必知必会题！
::: details 点击查看详细答案
- `HashCode`直接对比的是对象地址的哈希值（存在哈希冲突），`equal`如果没重写对比的还是`HashCode`，一般重写对比对象的属性是否一样。
- 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，我们才认为这两个对象相等。 
- 如果两个对象的`hashCode` 值不相等，我们就可以直接认为这两个对象不相等。 
:::

### 23. 为什么重写`equals()`方法必须重写`hashCode()`方法？:star::star::one:
- `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。
-  两个对象有相同的 `hashCode` 值，他们也不一定是相等的（哈希碰撞）。

**题评：** 必知必会题
::: details 点击查看详细答案
暂无
:::

### 24. 字符串常量池的作用？:star::star::star::two:
- 提升性能，直接引用不重新创建字符串对象
- 避免字符串重复创建浪费内存空间

**题评：** 记住一点，只要出现字面量就一定会进入到常量池，例如 `new` `String(`"`ab`"`)`; 如果常量池没有“`ab`”则会创建两个对象，首先“`ab`”出现了会直接放在常量池中，然后`new`会在堆上再创建一个。
::: details 点击查看详细答案
`JVM` 为了提升性能和减少内存消耗针对字符串（`String` 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。如下所示，如果使用字符串常量池技术下面两个引用对象为同一个对象。字符串常量池中存放的是引用，所以当你使用多个字符串字面量具有相同内容的情况时，它们可以共享同一个常量池中的引用。这种共享和重用机制可以节省内存空间，因为多个字符串对象可以引用同一个常量池中的字符串。
```java
String aa = "ab";
// 直接返回字符串常量池中字符串对象”ab“的引用
String bb = "ab";
System.out.println(aa==bb);// true
```
:::

### 25. `String` `s1` = `new` `String(`"`abc`"`)`;这句话创建了几个字符串对象？:star::star::star::two:
会创建 `1` 或 `2` 个字符串对象。如果字符串常量池中不存在字符串对象“`abc`”的引用，那么会在堆中创建 `2` 个字符串对象“`abc`”，其中一个在字符串常量池中保存对应的引用。如果字符串常量池中已存在字符串对象“`abc`”的引用，则只会在堆中创建 `1` 个字符串对象“`abc`”。

**题评：** 暂无
::: details 点击查看详细答案
暂无
:::

### 26. `String`.`intern()` 方法有什么作用?:star::star::star::star::two:
`String`.`intern()` 是一个 `native`（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：
- 如果字符串常量池中保存了对应的字符串对象引用，就直接返回该引用。
- 如果字符串常量池中没有保存了对应的字符串对象引用，它会将当前字符串对象引用添加到常量池，并返回对应的引用。

**题评：** 经常问的题目
::: details 点击查看详细答案
优点：实现字符串常量的共享和重用，减少存储空间。
缺点：可能导致不必要的内存消耗，占用常量池内存。
```java
// 在堆中创建字符串对象”Java“
// 将字符串对象”Java“的引用保存在字符串常量池中
String s1 = "Java";
// 直接返回字符串常量池中字符串对象”Java“对应的引用
String s2 = s1.intern();
// 会在堆中在单独创建一个字符串对象
String s3 = new String("Java");
// 直接返回字符串常量池中字符串对象”Java“对应的引用
String s4 = s3.intern();
// s1 和 s2 指向的是堆中的同一个对象
System.out.println(s1 == s2); // true
// s3 和 s4 指向的是堆中不同的对象
System.out.println(s3 == s4); // false
// s1 和 s4 指向的是堆中的同一个对象
System.out.println(s1 == s4); //true
```
:::

### 27. `String` 类型本质:star::star::two:
`String` 的本质其实是一个 `char` 类型的数组 ，通过`final`修饰能够保证指向该数组地址的引用对象不能修改，但是数组本身内的值可以被修改。  所以这里还加了另一个关键字`private`，防止从外部进行修改 。因此`String` 是不可变的了 ， 但是也可以通过暴力反射来修改数组本身。

**题评：** 暂无
::: details 点击查看详细答案
暂无
:::

### 28. `instanceof` 关键字:star::star::one:
`Java`中的一个双目运算符 ，用来测试一个对象是否为一个类的实例 。

**题评：** 基础题
::: details 点击查看详细答案
`boolean` `result` = `obj` `instanceof` `Class` ，其中`obj`是一个对象，`Class`表示一个类或者接口，当 `obj` 为 `Class` 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果`result` 都返回 `true`，否则返回`false`。编译器会检查 `obj` 是否能转换成右边的`class`类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。  如果`obj`为`null`，那么返回`false`。
:::

### 29. `HashSet`如何检查重复？:star::star::star::one:
对象加入`HashSet`，首先计算`hashCode`值来判断加入的位置，如果没有冲突加入，如果有冲突调用`equals`方法来检查两个对象的内存地址是否相同。如果不同则散列到其他位置加入，相同则不加入。这样就大大减少`equals`的次数，提高了执行效率！

**题评：** 注：==判断的是内存地址，不是`hash`后的值。
::: details 点击查看详细答案
`equals`与==的区别：
 -  == 对于基本数据类型比较值，对于对象比较堆内存地址（对象地址不同一定不相等，但是相同不一定相等，因为有`Hash`冲突）。
 -  `equals()` 方法存在于 `Object` 类中，⽽ `Object` 类是所有类的直接或间接父类，因此所有的类都有 `equals()` 方法。
 -  类没有重写 `equals()` 方法 ：通过 `equals()` 比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 `Object` 类 `equals()` 方法。类重写了 `equals()` 方法 ：⼀般我们都重写 `equals()` 方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 `true(`即，认为这两个对象相等`)`。
 -  `String` 中的 `equals` ⽅法是被重写过的 ,`String` 的 `equals` ⽅法⽐较的是对象的值 。
 -  当创建 `String` = "`ab`" 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引⽤。如果没有就在常量池中重新创建⼀个对象（注意这里创建不是简单`new` `String(`"`ab`"`)`，这是在堆内存创建对象）。
 -  `String`中的`equals()`方法：比较字符数组中的值是否相等。
:::

### 30. `String`、`StringBuffer` 和 `StringBuilder` 的区别是什么?:star::star::star::star::three:
`String`是被`final`+`private`修饰是不可修改的对象，+号连接两个`String` 底层是创建了`StringBuilder`对象然后调用了`append`方法最后`toString`为`String`对象；只有`StringBuffer`线程安全；其他两个非线程安全；

**题评：** 重点题
::: details 点击查看详细答案
`String` 为`final`类型修饰的字符串对象，每次+操作 ： 隐式在堆上`new`了一个跟原字符串相同的`StringBuilder`对象，再调用`append`方法 拼接+后面的字符，因此每次使用`String`对象添加字符串都会重写创建 `StringBuilder`对象。建议使用`StringBuffer`和`StringBuilder`来进行操作。 另外`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的 。
:::