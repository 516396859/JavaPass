---
title: Java 进阶
icon: file
order: 5
author: Ms.Cheney
date: 2023-10-05
category:
    - Java 基础
copyright: 版权声明：本文为JavaPass博主「javapass.cn」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
---

### 0. 泛型和通配符了解吗？:star::star::star::star::three:
编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型  ，泛型一般有三种使用方式:泛型类、泛型接口、泛型方法 。
- 项目中哪里用到了泛型？ 
  1. 自定义接口通用返回结果
  2. 构建集合工具类（参考 `Collections` 中的 `sort`, `binarySearch` 方法）

通配符
泛型类型是固定的，某些场景下使用起来不太灵活，于是，通配符就来了！通配符可以允许类型参数变化，用来解决泛型无法协变的问题。  

```java
// 上边界通配符限制类型为 Person 的子类
<? extends Person>
// 下边界通配符限制类型为 Manager 的父类
<? super Manager>
```

- 通配符 ？和常用的泛型 T 之间有什么区别？ 
  1. T 可以用于声明变量或常量而 ? 不行。 
  2. T 一般用于声明泛型类或方法，通配符 ? 一般用于泛型方法的调用代码和形参。 
  3. T 在编译期会被擦除为限定类型或 Object，通配符用于捕获具体类型。 

**题评：** 暂无
::: details 点击查看详细答案
待补充
:::

### 1. `Java`的四种引用了解吗？:star::star::star::star::two:
强软弱虚：
- 强引用，在程序内存不足（`OOM`）的时候也不会被回收。
- 软引用，软引用在程序内存不足时，会被回收。
- 弱引用，弱引用就是只要`JVM`垃圾回收器发现了它，就会将之回收。
- 虚引用，虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 `ReferenceQueue` 中 ，其它引用是被`JVM`回收后才被传入 `ReferenceQueue` 中的 ，所以虚引用大多被用于引用销毁前的处理工作 。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 2. `Java`创建对象有几种方式？:star::star::star::four:
- `new`
- 反射：使用 `newInstance()` 
- `clone` 
- 反序列化：`ObjectInputStream` 类的 `readObject()` 方法 。 

**题评：** 考验基本功！
::: details 点击查看详细答案
待补充
:::

### 3. 避免`hash`冲突的方法?:star::star::star::two:
- 拉链法
- 开放地址法
- 再哈希

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 4. 深拷贝和浅拷贝的区别是什么?:star::star::star::three:
-  引用拷贝：不同引用指向同一个对象； 
- 浅拷贝：重新创建一个新的对象，新对象中的引用属性和老对象中的引用指向的对象相同，即外壳不一样，内部对象一样。
- 深拷贝：完全创建一个新的对象，内部的对象也是新的对象。

**题评：** 无
::: details 点击查看详细答案
浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。深拷贝 ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。 
:::

### 5. `final`有哪些用法?:star::star::star::star::three:
- 被`final`修饰的类不可以被继承。
- 被`final`修饰的方法不可以被重写。
- 被`final`修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变。
- 被`final`修饰的方法,`JVM`会尝试将其内联,以提高运行效率。
- 被`final`修饰的常量,在编译阶段会存入常量池中。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 6. `static`都有哪些用法?:star::star::star::two:
-  静态变量和静态方法.也就是被`static`所修饰的变量/方法都属于类的静态资源,类实例所共享。 
-  `static`也用于静态块，初次被加载的时候执行且仅会被执行一次，多用于初始化操作，类中可以有多个`static`块。 
-  是静态导包 ，导入某个类中的静态资源,并且不需要使用类名,可以直接使用资源名。 

**题评：** 无
::: details 点击查看详细答案
```java
import static java.lang.Math.*;
//System.out.println(Math.sin(20));传统做法
System.out.println(sin(20));
```
:::

### 7. `a`=`a`+`b`与`a`+=`b`有什么区别吗?:star::star::two:
+= 操作符会进行隐式自动类型转换,此处`a`+=`b`隐式的将加操作的结果类型强制转换为持有结果的类型,而`a`=`a`+`b`则不会自动进行类型转换：

**题评：** 无
::: details 点击查看详细答案
```java
byte a = 127;
byte b = 127;
b = a + b; // 报编译错误:cannot convert from int to byte
b += a;
```
:::

### 8. `try` `catch` `finally`，`try`里有`return`，`finally`还执行么？:star::star::star::three:
执行，并且`finally`的执行早于`try`里面的`return` ,当`try`和`catch`中有`return`时，`finally`仍然会执行  .`finally`是在`return`后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管`finally`中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在`finally`执行前确定的。`finally`中如果有 `return` 则返回的是`finally`中的结果。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 9. `Java`的异常类了解吗？:star::star::star::star::four:
在 `Java` 中，所有的异常都有一个共同的祖先 `java`.`lang` 包中的 `Throwable` 类。`Throwable` 类有两个重要的子类`Error`和`Exception`，而`Exception`包括运行时异常`(RuntimeException)`和被检查异常。 运行时异常也称为非受检异常。
- 运行时异常：`RuntimeException`及其子类都被称为运行时异常 ，编译器不会检查它，例如除零`ArithmeticException`异常  ，数组越界时产生的`IndexOutOfBoundsException`异常  ，`fail`-`fast`机制产生的`ConcurrentModificationException`异常。`NullPointerException`（空指针异常）
- 受检查异常：`Exception`类本身，以及`Exception`的子类中除了"运行时异常"之外的其它子类都属于被检查异常。  `Java`编译器会检查它 ，要么通过`throws`进行声明抛出，要么通过`try`-`catch`进行捕获处理，否则不能通过编译 。`IOException`  ，`FileNotFoundException`  ，`SQLException`  。 
- `Error`：和运行时异常一样，编译器也不会对错误进行检查  ，当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，`VirtualMachineError`，`OutOfMemoryError`、`StackOverflowError`、`ThreadDeath`  就属于错误。 

**题评：** 无
::: details 点击查看详细答案
被检查的异常适用于那些不是因程序引起的错误情况，比如：读取文件时文件不存在引发的`FileNotFoundException` 。然而，运行时异常通常都是由于糟糕的编程引起的，比如：在对象引用时没有确保对象非空而引起的 `NullPointerException` 。 

:::

### 10. `Throwable` 类常用方法有哪些？:star::star::two:
- `String` `getMessage()`: 返回异常发生时的简要描述 
- `String` `toString()`: 返回异常发生时的详细信息 
- `void` `printStackTrace()`: 在控制台上打印 `Throwable` 对象封装的异常信息 

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 11. `OOM`你遇到过哪些情况，`SOF`你遇到过哪些情况？:star::star::star::star::three:
- `OutOfMemoryError`异常  ，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生`OutOfMemoryError(OOM)`异常的可能。虚拟机栈和本地方法栈溢出：如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出`StackOverflowError`异常。如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。方法区溢出：方法区用于存放`Class`的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。也有可能是方法区中保存的`class`对象没有被及时回收掉或者`class`信息占用的内存超过了我们配置 。 堆内存大量创建对象也会导致`OOM`。
- `SOF`（堆栈溢出`StackOverflow`）：`StackOverflowError` 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误 ，递归调用，大量循环或死循环，全局变量是否过多，数组、`List`、`map`数据过大  。



**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 12. 简述协程、线程、程序、进程的基本概念。以及他们之间关系是什么?:star::star::star::star::three:
- 程序：是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。
- 进程：是程序的一次执行过程，是系统运行程序的基本单位 。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序 。
- 线程：与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多。
- 协程：一个线程可以有多个协程，协程只在用户态进行切换，不涉及到内核态，协程比线程又要更加节省开销。

**题评：** 无
::: details 点击查看详细答案
进程是操作系统资源分配的最小单位，线程是`CPU`调度的最小单位。
:::

### 13. 序列化和反序列化知道吗？:star::star::star::two:
如果我们需要持久化 `Java` 对象比如将 `Java` 对象保存在文件中，或者在网络传输 `Java` 对象，这些场景都需要用到序列化。
- 序列化： 将数据结构或对象转换成二进制字节流的过程。
- 反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 14. `Java` 序列化中如果有些字段不想进行序列化，怎么办？:star::star::one:
对于不想进行序列化的变量，使用 `transient` 关键字修饰 ，`transient` 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；一般使用`Hessian`、`protobuf`等协议而不用`JDK`自带的。
- 当对象被反序列化时，被 `transient` 修饰的变量值不会被持久化和恢复。`transient` 只能修饰变量，不能修饰类和方法。
- `transient` 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 `int` 类型，那么反序列后结果就是 `0`。
- `static` 变量因为不属于任何对象`(Object)`，所以无论有没有 `transient` 关键字修饰，均不会被序列化。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 15. `java`反射的作用与原理知道吗？:star::star::star::star::four:
- 反射机制是在运行时，对于任意一个类，只要给定类的名字 ，都能够知道这个类的所有属性和方法等信息。并可以实例化它并调用其方法。反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。
- 哪里会用到反射机制？  `jdbc`就是典型的反射 ，在`Spring`框架中代理的实现等都使用了反射。
- 反射的实现方式：获取`Class`对象，有`4`中方法： `1`）`Class`.`forName(`“类的路径”`)`； `2`）类名.`class`   `3`）对象名.`getClass()`    `4`）基本类型的包装类，可以调用包装类的`Type`属性来获得该包装类的`Class`对象 。
- 反射的优缺点：优点：`1`）能够运行时动态获取类的实例，提高灵活性； `2`）与动态编译结合   缺点： `1`）使用反射性能较低，需要解析字节码，将内存中的对象进行解析。 解决方案： `1`、通过`setAccessible(true)`关闭`JDK`的安全检查来提升反射速度；相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性`)`。



**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 16. 注解的原理了解吗？:star::star::star::four:
可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。注解本质是一个继承了`Annotation` 的特殊接口。这个类啥都不用实现，就仅仅是标记一下。那如何通过注解执行业务逻辑呢？一般需要在拦截器或者过滤器中进行判断注解类型，然后执行对应的业务逻辑。注解的解析方法有哪几种？注解只有被解析之后才会生效，常见的解析方法有两种：
- 编译期直接扫描 ：编译器在编译 `Java` 代码的时候扫描对应的注解并处理，比如某个方法使用@`Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。- 运行期通过反射处理 ：像框架中自带的注解`(`比如 `Spring` 框架的 @`Value` 、@`Component)`都是通过反射来进行处理的。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 17. `Object` 有哪些常用方法？大致说一下每个方法的含义？:star::star::star::star::three:
- `clone`方法：保护方法，实现对象的浅复制，只有实现了 `Cloneable` 接口才可以调用该方法，否则抛出`CloneNotSupportedException` 异常，深拷贝也需要实现 `Cloneable`，同时其成员变量为引用类型的也需要实现 `Cloneable`，然后重写 `clone` 方法。
- `equals`方法：一般 `equals` 和 == 是不一样的，但是在 `Object` 中两者是一样的。子类一般都要重写这个方法。
- `hashCode` 方法 ：该方法用于哈希查找，重写了 `equals` 方法一般都要重写 `hashCode` 方法，`equals`相等则`hashCode`相等，`hashCode`相等还要判断值是否相等。例如 "`Aa`"和"`BB`"的哈希值相等。
- `wait` 方法  ：配合 `synchronized` 使用，`wait` 方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。`wait()` 方法一直等待，直到获得锁或者被中断。`wait(long` `timeout)`设定一个超时间隔，如果在规定时间内没有获得锁就返回。调用该方法后当前线程进入睡眠状态，直到以下事件发生。`1`. 其他线程调用了该对象的 `notify` 方法；`2`. 其他线程调用了该对象的 `notifyAll` 方法；`3`. 其他线程调用了 `interrupt` 中断该线程；`4`. 时间间隔到了。此时该线程就可以被调度了，如果是被中断的话就抛出一个 `InterruptedException` 异常。
- `notify` 方法 ：配合 `synchronized` 使用，该方法唤醒在该对象上等待队列中的某个线程（同步队列中的线程是给抢占 `CPU` 的线程，等待队列中的线程指的是等待唤醒的线程）。
- `notifyAll` 方法  ：配合 `synchronized` 使用，该方法唤醒在该对象上等待队列中的所有线程。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 18. 说说什么是 `fail`-`fast`？:star::star::star::three:
当多个线程对同一个集合的内容进行操作时，就可能会产生 `fail`-`fast` 事件，某一个线程 `A` 通过 `iterator` 去遍历某集合的过程中，若该集合的内容被其他线程所改变了，那么线程 `A` 访问集合时，就会抛出 `ConcurrentModificationException` 异常，产生 `fail`-`fast` 事件。


**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 19. 说说`Hashtable` 与 `HashMap` 的区别？:star::star::star::star::three:
- `Hashtable` 中大部分 `public` 修饰普通方法都是 `synchronized` 字段修饰的，是线程安全的，`HashMap` 是非线程安全的。
- `Hashtable` 的 `key` 不能为 `null`，`value` 也不能为 `null`  。`HashMap` 的 `key` 和 `value` 都可以为 `null`。
- `Hashtable` 直接使用对象的 `hash` 值  ，`HashMap` 为了提高计算效率，将哈希表的大小固定为了 `2` 的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。
- 如果需要线程安全高并发的话，推荐使用 `ConcurrentHashMap` 代替 `Hashtable`。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 20. `HashMap` 中的 `key` 我们可以使用任何类作为 `key` 吗？:star::star::three:
如果使用其他类的对象作为`key`，则`key`是引用地址，如果想让其值相等的对象也能够从`HashMap`中取值的话，需要重写`equals`和`hashCode`方法，让`hashCode`返回属性的`hashCode`，`equals`判断属性值是否相等。自定义 `key` 类的最佳实践是使之为不可变的。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 21. `HashMap`的长度为什么是`2`的`N`次方？:star::star::three:
为了能让 `HashMap` 存数据和取数据的效率高，尽可能地减少 `hash` 值的碰撞，也就是说尽量把数据能均匀的分配，每个链表或者红黑树长度尽量相等。  我们一般采用模来映射，取余（%）操作中如果除数是 `2` 的幂次，则等价于与其除数减一的与（&）操作（也就是说`hash` % `length` == `hash` &`(length` - `1)` 的前提是 `length` 是 `2` 的 `n` 次方）。并且，采用二进制位操作 & ，相对于 % 能够提高运算效率。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 22. `HashMap` 与 `ConcurrentHashMap` 的异同？:star::star::star::star::four:
- 都是 `key`-`value` 形式的存储数据
- `HashMap` 是线程不安全的，`ConcurrentHashMap` 是 `JUC` 下的线程安全的
- `HashMap` 底层数据结构是数组 + 链表（`JDK` `1`.`8` 之前）。`JDK` `1`.`8` 之后是数组 + 链表 + 红黑树。当链表中元素个数达到 `8` 的时候且桶数量超过`64`，链表的查询速度不如红黑树快，链表会转为红黑树，红黑树查询速度快；
- `HashMap` 初始数组大小为 `16`（默认），当出现扩容的时候（数量达到装载因子的比例），以 `2`* 数组大小的方式进行扩容；
- `ConcurrentHashMap` 在 `JDK` `1`.`8` 之前是采用分段锁来现实的 `Segment` + `HashEntry`，`Segment` 数组大小默认是 `16`，`2` 的 `n` 次方；`JDK` `1`.`8` 之后，抛弃`Segmant`，采用 `Node` + `CAS` + `Synchronized`+链表+红黑树（`Node`变成`treeNode`），来保证并发安全进行实现。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 23. `JDK` `1`.`7` 和 `JDK` `1`.`8` 的 `ConcurrentHashMap` 实现有什么不同？:star::star::star::four:
- 线程安全实现方式：`JDK` `1`.`7` 采用 `Segment` 分段锁来保证安全， `Segment` 是继承自 `ReentrantLock`。`JDK1`.`8` 放弃了 `Segment` 分段锁的设计，采用 `Node` + `CAS` + `synchronized` 保证线程安全，锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点。 
-  `Hash` 碰撞解决方法 : `JDK` `1`.`7` 采用拉链法，`JDK1`.`8` 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。 
- 并发度：`JDK` `1`.`7` 最大并发度是 `Segment` 的个数，默认是 `16`。`JDK` `1`.`8` 最大并发度是 `Node` 数组的大小，并发度更大。 

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 24. 红黑树性质了解吗？:star::star::star::three:
- 每个节点只能是黑色或者红色，根节点和叶子节点都是黑色 
- 红色节点的孩子节点是黑色的
- 从一个节点到该节点的后代叶子节点的路径上黑色节点数目相同。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 25. `Java` `IO` 流了解吗？:star::star::star::three:
`IO` 即 `Input`/`Output`，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 `IO` 流。`IO` 流在 `Java` 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。
`Java` `IO` 流的 `40` 多个类都是从如下 `4` 个抽象类基类中派生出来的。
- `InputStream`/`Reader`: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- `OutputStream`/`Writer`: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 26. `I`/`O` 流为什么要分为字节流和字符流呢?:star::star::three:
- 字符流是由 `Java` 虚拟机将字节转换得到的，这个过程还算是比较耗时；对于文本数据使用字符流会更快，而对于视频音频等非文本数据可以使用字节流。
- 如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。因此，`I`/`O` 流就干脆提供了一个字符流接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 27. 字节缓冲流知道吗？:star::star::star::three:
`IO` 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 `IO` 操作，提高流的传输效率。字节缓冲流这里采用了装饰器模式来增强 `InputStream` 和`OutputStream`子类对象的功能。举个例子，我们可以通过 `BufferedInputStream`（字节缓冲输入流）来增强 `FileInputStream` 的功能。相反是`BufferedOutputStream`。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 28. `SPI`与`API`的区别？:star::star::star::three:
- 当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 `API` ，这种接口和实现都是放在实现方的。
- 当接口存在于调用方这边时，就是 `SPI` ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。


**题评：** 无
::: details 点击查看详细答案
待补充
:::

