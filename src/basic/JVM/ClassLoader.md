---
title: 类加载机制
icon: file
order: 2
author: Ms.Cheney
date: 2023-10-19
PageView: true
lastUpdated: true
category:
    - JVM
copyright: false
footer: 赣ICP备2023007682 | 使用 <a href="https://theme-hope.vuejs.press/zh/" target="_blank">VuePress Theme Hope</a> 主题 | MIT 协议, 版权所有 © 2023-Cheney,2018-present Mr.Hope
# 版权声明：本文为JavaPass博主「javapass.cn」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
--- 



### 1. 类加载的详细过程了解吗？:star::star::five:
- 加载：每个类都有加载它的`ClassLoader`，将`class`文件加载到内存中，将静态数据结构加载到运行时常量池中，在堆中生成代表这个类的`class`对象。
- 连接：包括验证、准备、解析三步骤；
     `1`. 验证：验证`class`文件的规范性，保证虚拟机自身安全；
     `2`. 准备：为`static`类变量在方法区中分配内存并设置初始值。
     `3`.  解析：将方法区中常量池中的符号引用替换为直接引用。
- 初始化：执行类中定义执行类构造器方法的过程 ，创建实例对象时进行。
- 使用：调用对象的方法或者类的静态方法；
- 卸载：`Class`对象被`GC`，在没有任何地方被引用、类加载器被`GC`、没有任何对象时卸载。

**题评：** 没有意义的题目，只能硬背了！
::: details 点击查看详细答案
待补充
:::

### 2. 类加载器原理懂吗？:star::star::star::four:
类加载器的主要作用是将`class`字节码文件加载到`JVM`中，类加载器并不会一次性加载所有的类，而是根据需要去动态加载。`JVM`内置了三大类加载器：启动类加载器：最顶层的加载器加载`java`的核心类库（`jre`核心类库）、扩展类加载器：加载`java`的扩展库`ext`下的`jar`包、程序类加载器：负责加载当前应用路径下的所有`jar`包和类；最后加载类通过双亲委派机制加载的。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 3. 双亲委派机制知道吗？:star::star::star::four:
双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。即加载任意一个类都要 加载器唯一、这个类唯一。而加载器根据类的全限定类名来加载到`JVM`内存中再转为类对象。在类加载的时候，首先不会自己去加载类而是把这个加载请求委派给父类去加载，如果父类加载了直接返回，如果没加载则也递归向上级父类委派；只有当父类加载器没找到所需的类也就是加载不了，子类才尝试自己加载；总结：自底向上委派加载，自顶向下尝试加载；如果都没找到该类则抛出`ClassNotFound`异常；保证了任意一个类只能被加载一次，且加载器是唯一的。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 4. 为什么需要双亲委派模型？:star::star::star::four:
果没有双亲委派，那么用户是不是可以自己定义一个`java`.`lang`.`Object`的同名类，`java`.`lang`.`String`的同名类，并把它放到`ClassPath`中,那么类之间的比较结果及类的唯一性将无法保证，因此，为什么需要双亲委派模型？防止内存中出现多份同样的字节码。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 5. 怎么打破双亲委派模型？:star::star::star::star::four:
打破双亲委派机制则不仅要继承`ClassLoader`类，还要重写`loadClass`和`findClass`方法。  即原来的`loadClass`默认向父类加载，这里可以调用`findClass`自己加载。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 6. `Java`类的初始化知道吗？:star::star::star::star::three:
类的初始化也是延迟的，直到类第一次被主动使用，`JVM` 才会初始化类。  初始化过程的主要操作是执行静态代码块和初始化静态域`(`静态变量，常量池加载到运行时常量池`)`。在一个类被初始化之前，它的直接父类也需要被初始化。  

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 7. 加载到内存中的 `class` 数量太多或者体积太大怎么办？:star::star::star::four:
增加 `Metaspace` 的大小  ： -`XX`:`MaxMetaspaceSize`=`512m` 

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 8. `JVM` 组成结构清楚吗？:star::star::star::star::four:
包括两个子系统和两个组件：类加载和执行引擎、运行时内存结构和本地接口；
- 类加载：根据给定的类全限定名加载`class`文件到方法区中，然后在堆上创建一个 `java`.`lang`.`Class`对象
- 执行引擎：执行`class`中的指令；
- 本地接口：调用`native` 方法也就是底层封装的方法的接口；
- 运行时内存结构：常说的`JVM`内存结构；
整个过程就是，.`java`文件首先被编译成.`class`文件，然后被类加载器加载到方法区中。.`class`文件并不能直接被底层操作系统执行，所以需要解释器进行解释成机器指令，再交给操作系统`CPU`去执行。其中有些底层实现调用了`native`本地方法，`C`语言实现的。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 9. 字符串常量池知道吗？:star::star::star::four:
字符串常量池原来放在方法区，由于不好垃圾回收于是后来`jdk8`是存放在堆上的，字符串常量池存储的是`string`对象的直接引用，而不是直接存放的对象，是一张`string` `table`。`String` 对象还是放在堆内存上，只是调用`intern`方法之后，会在`string` `table`中指定其引用。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 10. 常量池与运行时常量池的区别是什么？:star::star::star::four:
常量池和运行时常量池都是`Class`的一部分，都在方法区，随着类加载而加载；常量池用于存放编译期生成的各种字面量与符号引用。加载完后就放在运行时常量池中。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 11. 堆外内存与堆内存有什么不同？:star::star::four:
堆外内存, 常常又叫做直接内存。  把内存对象分配在`Java`虚拟机的堆以外的内存，  直接受操作系统管理（而不是虚拟机），能够在一定程度上减少垃圾回收对应用程序造成的影响。  我们经常用`java`.`nio`.`DirectByteBuffer`对象进行堆外内存的管理和使用，它会在对象创建的时候就分配堆外内存。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 12. 为什么用元空间替代永久代？:star::star::star::star::three:
- 永久代的空间难以确定，永久代占用的是`JVM`内存，难以调优。
- 元空间占用的是本地内存，无需进行调优。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 13. 为什么字符串常量池放在堆中？:star::star::star::star::four:
 因为永久代中需要进行`Full` `GC`才能垃圾回收，导致字符串常量池回收效率不高，提高回收效率。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 14. 使用堆外内存的优点？:star::star::star::three:
- 减少了垃圾回收  
- 加快了复制的速度  

**题评：** 无
::: details 点击查看详细答案
待补充
:::

### 15. 对象创建的流程？:star::star::star::star::three:
- 判断类是否加载，没有加载则先加载类
- 类加载后，接下来分配内存。判断堆内存是否规整（连续）和垃圾回收算法有关，分为指针碰撞（规整的内存分配算法：指针左边的是已经分配的内存，右边是未分配内存）和空闲列表（零碎内存分配算法：维护一个内存记录表，记录已分配的内存地址，从未分配的内存中找一块足够大的内存分配）。
- 并发`CAS`分配内存，因为高并发创建对象时，可能多个进程判断某个内存是空闲的，于是都去占用创建对象。
- 将分配到的内存都初始化为`0`值，并将引用指向新的对象空间。

**题评：** 无
::: details 点击查看详细答案
待补充
:::

